{"version":3,"sources":["../src/operators.ts","../node_modules/.pnpm/drizzle-orm@0.40.0_postgres@3.4.4/node_modules/src/sql/expressions/conditions.ts"],"names":["operators_exports","__export","bboxAbove","bboxBelow","bboxContain","bboxContained","bboxLeft","bboxOverlaps","bboxOverlapsND","bboxOverlapsOrAbove","bboxOverlapsOrBelow","bboxOverlapsOrLeft","bboxOverlapsOrRight","bboxRight","bboxSame","distanceBox","distanceBoxND","distanceCPA","distanceCentroidND","distanceKNN","eq","bindIfParam","value","column","isDriverValueEncoder","isSQLWrapper","is","Param","Placeholder","Column","Table","View","left","right","sql","gisExtensionSchema"],"mappings":"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","sourcesContent":["/**\n * @packageDocumentation\n * Binary operators for use with GIS objects.\n *\n *  @groupDescription Bounding Box Operators\n * These operators calculate values related to the bounding boxes of their arguments.\n * {@link https://postgis.net/docs/reference.html#operators-bbox}\n *\n * @groupDescription Distance Operators\n * These operators calculate distance between their arguments\n * {@link https://postgis.net/docs/reference.html#operators-distance}\n */\n\nimport {\n  type SQLWrapper,\n  type SQL,\n  sql,\n  type BinaryOperator,\n  bindIfParam,\n} from \"drizzle-orm\";\nimport { gisExtensionSchema } from \"~/config\";\n\n/** && — Returns TRUE if A's 2D bounding box intersects B's 2D bounding box.\n *\n * @group Bounding Box Operators\n * @link https://postgis.net/docs/geometry_overlaps.html\n */\nexport const bboxOverlaps: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}&&) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** && — Returns TRUE if A's n-D bounding box intersects B's n-D bounding box.\n *\n * @group Bounding Box Operators\n * @link https://postgis.net/docs/geometry_overlaps_nd.html\n */\nexport const bboxOverlapsND: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}&&&) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** &< — Returns TRUE if A's bounding box overlaps or is to the left of B's.\n *\n * @group Bounding Box Operators\n * @link https://postgis.net/docs/ST_Geometry_Overleft.html\n */\nexport const bboxOverlapsOrLeft: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}&<) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** &<| — Returns TRUE if A's bounding box overlaps or is below B's.\n *\n * @group Bounding Box Operators\n * @link https://postgis.net/docs/ST_Geometry_Overbelow.html\n */\nexport const bboxOverlapsOrBelow: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}&<|) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** &> — Returns TRUE if A' bounding box overlaps or is to the right of B's.\n *\n * @group Bounding Box Operators\n * @link https://postgis.net/docs/ST_Geometry_Overright.html\n */\nexport const bboxOverlapsOrRight: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}&>) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** << — Returns TRUE if A's bounding box is strictly to the left of B's.\n *\n * @group Bounding Box Operators\n * @link https://postgis.net/docs/ST_Geometry_Left.html\n */\nexport const bboxLeft: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}<<) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** <<| — Returns TRUE if A's bounding box is strictly below B's.\n *\n * @group Bounding Box Operators\n * @link https://postgis.net/docs/ST_Geometry_Below.html\n */\nexport const bboxBelow: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}<<|) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** |&> — Returns TRUE if A's bounding box overlaps or is above B's.\n *\n * @group Bounding Box Operators\n * @link https://postgis.net/docs/ST_Geometry_Overabove.html\n */\nexport const bboxOverlapsOrAbove: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}|&>) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** |>> — Returns TRUE if A's bounding box is strictly above B's.\n *\n * @group Bounding Box Operators\n * @link https://postgis.net/docs/ST_Geometry_Above.html\n */\nexport const bboxAbove: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}|>>) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** >> — Returns TRUE if A's bounding box is strictly to the right of B's.\n *\n * @group Bounding Box Operators\n * @link https://postgis.net/docs/ST_Geometry_Right.html\n */\nexport const bboxRight: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}>>) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** = — Returns TRUE if the coordinates and coordinate order geometry/geography A are the same as the coordinates and coordinate order of geometry/geography B.\n *\n * @group Other Operators\n * @link https://postgis.net/docs/ST_Geometry_EQ.html\n */\nexport const eq: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}=) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** ~= — Returns TRUE if A's bounding box is the same as B's.\n *\n * @group Bounding Box Operators\n * @link https://postgis.net/docs/ST_Geometry_Same.html\n */\nexport const bboxSame: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}~=) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** @ — Returns TRUE if A's bounding box is contained by B's.\n *\n * @group Bounding Box Operators\n * @link https://postgis.net/docs/ST_Geometry_Contained.html\n */\nexport const bboxContained: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}@) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** ~ — Returns TRUE if A's bounding box contains B's.\n *\n * @group Bounding Box Operators\n * @link https://postgis.net/docs/ST_Geometry_Contain.html\n */\nexport const bboxContain: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}~) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** <-> — Returns the 2D distance between A and B.\n *\n * @group Distance Operators\n * @link https://postgis.net/docs/geometry_distance_knn.html\n */\nexport const distanceKNN: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL<number> => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}<->) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** |=| — Returns the distance between A and B trajectories at their closest point of approach.\n *\n * @group Distance Operators\n * @link https://postgis.net/docs/geometry_distance_cpa.html\n */\nexport const distanceCPA: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL<number> => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}|=|) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** <#> — Returns the 2D distance between A and B bounding boxes.\n *\n * @group Distance Operators\n * @link https://postgis.net/docs/geometry_distance_box.html\n */\nexport const distanceBox: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL<number> => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}<#>) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** <<->> — Returns the n-D distance between the centroids of A and B bounding boxes.\n *\n * @group Distance Operators\n * @link https://postgis.net/docs/geometry_distance_centroid_nd.html\n */\nexport const distanceCentroidND: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL<number> => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}<<->>) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** <<#>> — Returns the n-D distance between A and B bounding boxes.\n *\n * @group Distance Operators\n * @link https://postgis.net/docs/geometry_distance_box_nd.html\n */\nexport const distanceBoxND: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL<number> => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}<<#>>) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n","import { type AnyColumn, Column, type GetColumnData } from '~/column.ts';\nimport { is } from '~/entity.ts';\nimport { Table } from '~/table.ts';\nimport {\n\tisDriverValueEncoder,\n\tisSQLWrapper,\n\tParam,\n\tPlaceholder,\n\tSQL,\n\tsql,\n\ttype SQLChunk,\n\ttype SQLWrapper,\n\tStringChunk,\n\tView,\n} from '../sql.ts';\n\nexport function bindIfParam(value: unknown, column: SQLWrapper): SQLChunk {\n\tif (\n\t\tisDriverValueEncoder(column)\n\t\t&& !isSQLWrapper(value)\n\t\t&& !is(value, Param)\n\t\t&& !is(value, Placeholder)\n\t\t&& !is(value, Column)\n\t\t&& !is(value, Table)\n\t\t&& !is(value, View)\n\t) {\n\t\treturn new Param(value, column);\n\t}\n\treturn value as SQLChunk;\n}\n\nexport interface BinaryOperator {\n\t<TColumn extends Column>(\n\t\tleft: TColumn,\n\t\tright: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n\t): SQL;\n\t<T>(left: SQL.Aliased<T>, right: T | SQLWrapper): SQL;\n\t<T extends SQLWrapper>(\n\t\tleft: Exclude<T, SQL.Aliased | Column>,\n\t\tright: unknown,\n\t): SQL;\n}\n\n/**\n * Test that two values are equal.\n *\n * Remember that the SQL standard dictates that\n * two NULL values are not equal, so if you want to test\n * whether a value is null, you may want to use\n * `isNull` instead.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made by Ford\n * db.select().from(cars)\n *   .where(eq(cars.make, 'Ford'))\n * ```\n *\n * @see isNull for a way to test equality to NULL.\n */\nexport const eq: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} = ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test that two values are not equal.\n *\n * Remember that the SQL standard dictates that\n * two NULL values are not equal, so if you want to test\n * whether a value is not null, you may want to use\n * `isNotNull` instead.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars not made by Ford\n * db.select().from(cars)\n *   .where(ne(cars.make, 'Ford'))\n * ```\n *\n * @see isNotNull for a way to test whether a value is not null.\n */\nexport const ne: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} <> ${bindIfParam(right, left)}`;\n};\n\n/**\n * Combine a list of conditions with the `and` operator. Conditions\n * that are equal `undefined` are automatically ignored.\n *\n * ## Examples\n *\n * ```ts\n * db.select().from(cars)\n *   .where(\n *     and(\n *       eq(cars.make, 'Volvo'),\n *       eq(cars.year, 1950),\n *     )\n *   )\n * ```\n */\nexport function and(...conditions: (SQLWrapper | undefined)[]): SQL | undefined;\nexport function and(\n\t...unfilteredConditions: (SQLWrapper | undefined)[]\n): SQL | undefined {\n\tconst conditions = unfilteredConditions.filter(\n\t\t(c): c is Exclude<typeof c, undefined> => c !== undefined,\n\t);\n\n\tif (conditions.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tif (conditions.length === 1) {\n\t\treturn new SQL(conditions);\n\t}\n\n\treturn new SQL([\n\t\tnew StringChunk('('),\n\t\tsql.join(conditions, new StringChunk(' and ')),\n\t\tnew StringChunk(')'),\n\t]);\n}\n\n/**\n * Combine a list of conditions with the `or` operator. Conditions\n * that are equal `undefined` are automatically ignored.\n *\n * ## Examples\n *\n * ```ts\n * db.select().from(cars)\n *   .where(\n *     or(\n *       eq(cars.make, 'GM'),\n *       eq(cars.make, 'Ford'),\n *     )\n *   )\n * ```\n */\nexport function or(...conditions: (SQLWrapper | undefined)[]): SQL | undefined;\nexport function or(\n\t...unfilteredConditions: (SQLWrapper | undefined)[]\n): SQL | undefined {\n\tconst conditions = unfilteredConditions.filter(\n\t\t(c): c is Exclude<typeof c, undefined> => c !== undefined,\n\t);\n\n\tif (conditions.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tif (conditions.length === 1) {\n\t\treturn new SQL(conditions);\n\t}\n\n\treturn new SQL([\n\t\tnew StringChunk('('),\n\t\tsql.join(conditions, new StringChunk(' or ')),\n\t\tnew StringChunk(')'),\n\t]);\n}\n\n/**\n * Negate the meaning of an expression using the `not` keyword.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars _not_ made by GM or Ford.\n * db.select().from(cars)\n *   .where(not(inArray(cars.make, ['GM', 'Ford'])))\n * ```\n */\nexport function not(condition: SQLWrapper): SQL {\n\treturn sql`not ${condition}`;\n}\n\n/**\n * Test that the first expression passed is greater than\n * the second expression.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made after 2000.\n * db.select().from(cars)\n *   .where(gt(cars.year, 2000))\n * ```\n *\n * @see gte for greater-than-or-equal\n */\nexport const gt: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} > ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test that the first expression passed is greater than\n * or equal to the second expression. Use `gt` to\n * test whether an expression is strictly greater\n * than another.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made on or after 2000.\n * db.select().from(cars)\n *   .where(gte(cars.year, 2000))\n * ```\n *\n * @see gt for a strictly greater-than condition\n */\nexport const gte: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} >= ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test that the first expression passed is less than\n * the second expression.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made before 2000.\n * db.select().from(cars)\n *   .where(lt(cars.year, 2000))\n * ```\n *\n * @see lte for less-than-or-equal\n */\nexport const lt: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} < ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test that the first expression passed is less than\n * or equal to the second expression.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made before 2000.\n * db.select().from(cars)\n *   .where(lte(cars.year, 2000))\n * ```\n *\n * @see lt for a strictly less-than condition\n */\nexport const lte: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} <= ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test whether the first parameter, a column or expression,\n * has a value from a list passed as the second argument.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made by Ford or GM.\n * db.select().from(cars)\n *   .where(inArray(cars.make, ['Ford', 'GM']))\n * ```\n *\n * @see notInArray for the inverse of this test\n */\nexport function inArray<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function inArray<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function inArray<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function inArray(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\treturn sql`false`;\n\t\t}\n\t\treturn sql`${column} in ${values.map((v) => bindIfParam(v, column))}`;\n\t}\n\n\treturn sql`${column} in ${bindIfParam(values, column)}`;\n}\n\n/**\n * Test whether the first parameter, a column or expression,\n * has a value that is not present in a list passed as the\n * second argument.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made by any company except Ford or GM.\n * db.select().from(cars)\n *   .where(notInArray(cars.make, ['Ford', 'GM']))\n * ```\n *\n * @see inArray for the inverse of this test\n */\nexport function notInArray<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function notInArray<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function notInArray<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function notInArray(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\treturn sql`true`;\n\t\t}\n\t\treturn sql`${column} not in ${values.map((v) => bindIfParam(v, column))}`;\n\t}\n\n\treturn sql`${column} not in ${bindIfParam(values, column)}`;\n}\n\n/**\n * Test whether an expression is NULL. By the SQL standard,\n * NULL is neither equal nor not equal to itself, so\n * it's recommended to use `isNull` and `notIsNull` for\n * comparisons to NULL.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars that have no discontinuedAt date.\n * db.select().from(cars)\n *   .where(isNull(cars.discontinuedAt))\n * ```\n *\n * @see isNotNull for the inverse of this test\n */\nexport function isNull(value: SQLWrapper): SQL {\n\treturn sql`${value} is null`;\n}\n\n/**\n * Test whether an expression is not NULL. By the SQL standard,\n * NULL is neither equal nor not equal to itself, so\n * it's recommended to use `isNull` and `notIsNull` for\n * comparisons to NULL.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars that have been discontinued.\n * db.select().from(cars)\n *   .where(isNotNull(cars.discontinuedAt))\n * ```\n *\n * @see isNull for the inverse of this test\n */\nexport function isNotNull(value: SQLWrapper): SQL {\n\treturn sql`${value} is not null`;\n}\n\n/**\n * Test whether a subquery evaluates to have any rows.\n *\n * ## Examples\n *\n * ```ts\n * // Users whose `homeCity` column has a match in a cities\n * // table.\n * db\n *   .select()\n *   .from(users)\n *   .where(\n *     exists(db.select()\n *       .from(cities)\n *       .where(eq(users.homeCity, cities.id))),\n *   );\n * ```\n *\n * @see notExists for the inverse of this test\n */\nexport function exists(subquery: SQLWrapper): SQL {\n\treturn sql`exists ${subquery}`;\n}\n\n/**\n * Test whether a subquery doesn't include any result\n * rows.\n *\n * ## Examples\n *\n * ```ts\n * // Users whose `homeCity` column doesn't match\n * // a row in the cities table.\n * db\n *   .select()\n *   .from(users)\n *   .where(\n *     notExists(db.select()\n *       .from(cities)\n *       .where(eq(users.homeCity, cities.id))),\n *   );\n * ```\n *\n * @see exists for the inverse of this test\n */\nexport function notExists(subquery: SQLWrapper): SQL {\n\treturn sql`not exists ${subquery}`;\n}\n\n/**\n * Test whether an expression is between two values. This\n * is an easier way to express range tests, which would be\n * expressed mathematically as `x <= a <= y` but in SQL\n * would have to be like `a >= x AND a <= y`.\n *\n * Between is inclusive of the endpoints: if `column`\n * is equal to `min` or `max`, it will be TRUE.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made between 1990 and 2000\n * db.select().from(cars)\n *   .where(between(cars.year, 1990, 2000))\n * ```\n *\n * @see notBetween for the inverse of this test\n */\nexport function between<T>(\n\tcolumn: SQL.Aliased,\n\tmin: T | SQLWrapper,\n\tmax: T | SQLWrapper,\n): SQL;\nexport function between<TColumn extends AnyColumn>(\n\tcolumn: TColumn,\n\tmin: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n\tmax: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n): SQL;\nexport function between<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tmin: unknown,\n\tmax: unknown,\n): SQL;\nexport function between(column: SQLWrapper, min: unknown, max: unknown): SQL {\n\treturn sql`${column} between ${bindIfParam(min, column)} and ${\n\t\tbindIfParam(\n\t\t\tmax,\n\t\t\tcolumn,\n\t\t)\n\t}`;\n}\n\n/**\n * Test whether an expression is not between two values.\n *\n * This, like `between`, includes its endpoints, so if\n * the `column` is equal to `min` or `max`, in this case\n * it will evaluate to FALSE.\n *\n * ## Examples\n *\n * ```ts\n * // Exclude cars made in the 1970s\n * db.select().from(cars)\n *   .where(notBetween(cars.year, 1970, 1979))\n * ```\n *\n * @see between for the inverse of this test\n */\nexport function notBetween<T>(\n\tcolumn: SQL.Aliased,\n\tmin: T | SQLWrapper,\n\tmax: T | SQLWrapper,\n): SQL;\nexport function notBetween<TColumn extends AnyColumn>(\n\tcolumn: TColumn,\n\tmin: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n\tmax: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n): SQL;\nexport function notBetween<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tmin: unknown,\n\tmax: unknown,\n): SQL;\nexport function notBetween(\n\tcolumn: SQLWrapper,\n\tmin: unknown,\n\tmax: unknown,\n): SQL {\n\treturn sql`${column} not between ${\n\t\tbindIfParam(\n\t\t\tmin,\n\t\t\tcolumn,\n\t\t)\n\t} and ${bindIfParam(max, column)}`;\n}\n\n/**\n * Compare a column to a pattern, which can include `%` and `_`\n * characters to match multiple variations. Including `%`\n * in the pattern matches zero or more characters, and including\n * `_` will match a single character.\n *\n * ## Examples\n *\n * ```ts\n * // Select all cars with 'Turbo' in their names.\n * db.select().from(cars)\n *   .where(like(cars.name, '%Turbo%'))\n * ```\n *\n * @see ilike for a case-insensitive version of this condition\n */\nexport function like(column: Column | SQL.Aliased | SQL, value: string | SQLWrapper): SQL {\n\treturn sql`${column} like ${value}`;\n}\n\n/**\n * The inverse of like - this tests that a given column\n * does not match a pattern, which can include `%` and `_`\n * characters to match multiple variations. Including `%`\n * in the pattern matches zero or more characters, and including\n * `_` will match a single character.\n *\n * ## Examples\n *\n * ```ts\n * // Select all cars that don't have \"ROver\" in their name.\n * db.select().from(cars)\n *   .where(notLike(cars.name, '%Rover%'))\n * ```\n *\n * @see like for the inverse condition\n * @see notIlike for a case-insensitive version of this condition\n */\nexport function notLike(column: Column | SQL.Aliased | SQL, value: string | SQLWrapper): SQL {\n\treturn sql`${column} not like ${value}`;\n}\n\n/**\n * Case-insensitively compare a column to a pattern,\n * which can include `%` and `_`\n * characters to match multiple variations. Including `%`\n * in the pattern matches zero or more characters, and including\n * `_` will match a single character.\n *\n * Unlike like, this performs a case-insensitive comparison.\n *\n * ## Examples\n *\n * ```ts\n * // Select all cars with 'Turbo' in their names.\n * db.select().from(cars)\n *   .where(ilike(cars.name, '%Turbo%'))\n * ```\n *\n * @see like for a case-sensitive version of this condition\n */\nexport function ilike(column: Column | SQL.Aliased | SQL, value: string | SQLWrapper): SQL {\n\treturn sql`${column} ilike ${value}`;\n}\n\n/**\n * The inverse of ilike - this case-insensitively tests that a given column\n * does not match a pattern, which can include `%` and `_`\n * characters to match multiple variations. Including `%`\n * in the pattern matches zero or more characters, and including\n * `_` will match a single character.\n *\n * ## Examples\n *\n * ```ts\n * // Select all cars that don't have \"Rover\" in their name.\n * db.select().from(cars)\n *   .where(notLike(cars.name, '%Rover%'))\n * ```\n *\n * @see ilike for the inverse condition\n * @see notLike for a case-sensitive version of this condition\n */\nexport function notIlike(column: Column | SQL.Aliased | SQL, value: string | SQLWrapper): SQL {\n\treturn sql`${column} not ilike ${value}`;\n}\n\n/**\n * Test that a column or expression contains all elements of\n * the list passed as the second argument.\n *\n * ## Throws\n *\n * The argument passed in the second array can't be empty:\n * if an empty is provided, this method will throw.\n *\n * ## Examples\n *\n * ```ts\n * // Select posts where its tags contain \"Typescript\" and \"ORM\".\n * db.select().from(posts)\n *   .where(arrayContains(posts.tags, ['Typescript', 'ORM']))\n * ```\n *\n * @see arrayContained to find if an array contains all elements of a column or expression\n * @see arrayOverlaps to find if a column or expression contains any elements of an array\n */\nexport function arrayContains<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayContains<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayContains<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function arrayContains(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\tthrow new Error('arrayContains requires at least one value');\n\t\t}\n\t\tconst array = sql`${bindIfParam(values, column)}`;\n\t\treturn sql`${column} @> ${array}`;\n\t}\n\n\treturn sql`${column} @> ${bindIfParam(values, column)}`;\n}\n\n/**\n * Test that the list passed as the second argument contains\n * all elements of a column or expression.\n *\n * ## Throws\n *\n * The argument passed in the second array can't be empty:\n * if an empty is provided, this method will throw.\n *\n * ## Examples\n *\n * ```ts\n * // Select posts where its tags contain \"Typescript\", \"ORM\" or both,\n * // but filtering posts that have additional tags.\n * db.select().from(posts)\n *   .where(arrayContained(posts.tags, ['Typescript', 'ORM']))\n * ```\n *\n * @see arrayContains to find if a column or expression contains all elements of an array\n * @see arrayOverlaps to find if a column or expression contains any elements of an array\n */\nexport function arrayContained<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayContained<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayContained<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function arrayContained(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\tthrow new Error('arrayContained requires at least one value');\n\t\t}\n\t\tconst array = sql`${bindIfParam(values, column)}`;\n\t\treturn sql`${column} <@ ${array}`;\n\t}\n\n\treturn sql`${column} <@ ${bindIfParam(values, column)}`;\n}\n\n/**\n * Test that a column or expression contains any elements of\n * the list passed as the second argument.\n *\n * ## Throws\n *\n * The argument passed in the second array can't be empty:\n * if an empty is provided, this method will throw.\n *\n * ## Examples\n *\n * ```ts\n * // Select posts where its tags contain \"Typescript\", \"ORM\" or both.\n * db.select().from(posts)\n *   .where(arrayOverlaps(posts.tags, ['Typescript', 'ORM']))\n * ```\n *\n * @see arrayContains to find if a column or expression contains all elements of an array\n * @see arrayContained to find if an array contains all elements of a column or expression\n */\nexport function arrayOverlaps<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayOverlaps<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayOverlaps<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function arrayOverlaps(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\tthrow new Error('arrayOverlaps requires at least one value');\n\t\t}\n\t\tconst array = sql`${bindIfParam(values, column)}`;\n\t\treturn sql`${column} && ${array}`;\n\t}\n\n\treturn sql`${column} && ${bindIfParam(values, column)}`;\n}\n"]}