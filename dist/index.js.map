{"version":3,"sources":["../src/models.ts","../node_modules/.pnpm/drizzle-orm@0.40.0_postgres@3.4.4/node_modules/src/entity.ts","../node_modules/.pnpm/drizzle-orm@0.40.0_postgres@3.4.4/node_modules/src/column.ts","../node_modules/.pnpm/drizzle-orm@0.40.0_postgres@3.4.4/node_modules/src/column-builder.ts","../node_modules/.pnpm/drizzle-orm@0.40.0_postgres@3.4.4/node_modules/src/table.utils.ts","../node_modules/.pnpm/drizzle-orm@0.40.0_postgres@3.4.4/node_modules/src/pg-core/foreign-keys.ts","../node_modules/.pnpm/drizzle-orm@0.40.0_postgres@3.4.4/node_modules/src/tracing-utils.ts","../node_modules/.pnpm/drizzle-orm@0.40.0_postgres@3.4.4/node_modules/src/pg-core/unique-constraint.ts","../node_modules/.pnpm/drizzle-orm@0.40.0_postgres@3.4.4/node_modules/src/pg-core/utils/array.ts","../node_modules/.pnpm/drizzle-orm@0.40.0_postgres@3.4.4/node_modules/src/pg-core/columns/common.ts","../node_modules/.pnpm/drizzle-orm@0.40.0_postgres@3.4.4/node_modules/src/pg-core/columns/enum.ts","../node_modules/.pnpm/drizzle-orm@0.40.0_postgres@3.4.4/node_modules/src/subquery.ts","../node_modules/.pnpm/drizzle-orm@0.40.0_postgres@3.4.4/node_modules/drizzle-orm/version.js","../node_modules/.pnpm/drizzle-orm@0.40.0_postgres@3.4.4/node_modules/src/tracing.ts","../node_modules/.pnpm/drizzle-orm@0.40.0_postgres@3.4.4/node_modules/src/view-common.ts","../node_modules/.pnpm/drizzle-orm@0.40.0_postgres@3.4.4/node_modules/src/table.ts","../node_modules/.pnpm/drizzle-orm@0.40.0_postgres@3.4.4/node_modules/src/sql/sql.ts","../node_modules/.pnpm/drizzle-orm@0.40.0_postgres@3.4.4/node_modules/src/sql/expressions/conditions.ts","../node_modules/.pnpm/drizzle-orm@0.40.0_postgres@3.4.4/node_modules/src/utils.ts","../node_modules/.pnpm/drizzle-orm@0.40.0_postgres@3.4.4/node_modules/src/pg-core/columns/custom.ts","../src/functions.ts","../src/config.ts","../src/operators.ts"],"names":["models_exports","__export","box2D","box2DfromDriver","fromDriver","geometry","geometryCollection","lineString","multiLineString","multiPoint","multiPolygon","point","polygon","entityKind","hasOwnEntityKind","is","value","type","cls","Column","table","config","ColumnBuilder","name","dataType","columnType","fn","TableName","ForeignKeyBuilder","actions","columns","foreignColumns","action","ForeignKey","builder","columnNames","column","foreignColumnNames","chunks","iife","args","uniqueKeyName","UniqueConstraintBuilder","UniqueConstraint","UniqueOnConstraintBuilder","nullsNotDistinct","parsePgArrayValue","arrayString","startFrom","inQuotes","i","char","parsePgNestedArray","result","lastCharIsComma","newStartFrom","parsePgArray","makePgArray","array","item","PgColumnBuilder","size","PgArrayBuilder","ref","as","foreignColumn","ExtraConfigColumn","PgColumn","opClass","IndexedColumn","keyAsName","indexConfig","baseBuilder","baseColumn","PgArray","_PgArray","range","v","isNestedArray","a","isPgEnumSym","isPgEnum","obj","PgEnumColumnBuilder","enumInstance","PgEnumColumn","Subquery","sql","selection","alias","isWith","WithSubquery","version","otel","rawTracer","tracer","span","e","ViewBaseConfig","Schema","Columns","ExtraConfigColumns","OriginalName","BaseName","IsAlias","ExtraConfigBuilder","IsDrizzleTable","Table","schema","baseName","FakePrimitiveParam","isSQLWrapper","mergeQueries","queries","query","StringChunk","SQL","_SQL","queryChunks","noopDecoder","_config","casing","escapeName","escapeParam","prepareTyping","inlineParams","paramStartIndex","chunk","Name","p","schemaName","tableName","columnName","View","viewName","Param","Placeholder","mappedValue","typings","escapeString","mappedValueAsString","decoder","condition","isDriverValueEncoder","noopEncoder","noopMapper","encoder","strings","params","paramIndex","param","empty","fromList","list","raw","str","join","separator","identifier","placeholder","Aliased","fieldAlias","IsDrizzleView","selectedFields","bindIfParam","getColumnNameAndConfig","b","PgCustomColumnBuilder","fieldConfig","customTypeParams","PgCustomColumn","customType","wkx","options","toDriver","match","pt","mp","functions_exports","addMeasure","area","asText","closestPoint","geoHash","geomFromGeoJSON","geomFromText","isValid","isValidReason","x","y","config_exports","gisExtensionSchema","setPostGISSchema","expression","geom1","geom2","maxChars","measureStart","measureEnd","operators_exports","bboxAbove","bboxBelow","bboxContain","bboxContained","bboxLeft","bboxOverlaps","bboxOverlapsND","bboxOverlapsOrAbove","bboxOverlapsOrBelow","bboxOverlapsOrLeft","bboxOverlapsOrRight","bboxRight","bboxSame","distanceBox","distanceBoxND","distanceCPA","distanceCentroidND","distanceKNN","eq","left","right"],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/consistent-type-definitions */\n// Inspired by @link https://github.com/drizzle-team/drizzle-orm/discussions/123#discussioncomment-6075834\nimport { sql } from \"drizzle-orm\";\nimport { customType } from \"drizzle-orm/pg-core\";\nimport type * as GeoJSON from \"~/geojsonTypes\";\n\nimport wkx from \"wkx\";\n\nexport type BaseGeometryType =\n  | \"Point\"\n  | \"MultiPoint\"\n  | \"LineString\"\n  | \"MultiLineString\"\n  | \"Polygon\"\n  | \"MultiPolygon\"\n  | \"GeometryCollection\";\n\nexport type GeometryType = BaseGeometryType | `${BaseGeometryType}Z`;\n\nexport type GeometryOptions =\n  | { type?: GeometryType; srid?: never; is3D?: boolean }\n  | { type: GeometryType; srid: number; is3D?: boolean };\n\nexport type GeometrySubtypeOptions = { srid?: number; is3D?: boolean };\n\nconst dataType = (options?: GeometryOptions) => {\n  let result = \"geometry\";\n  if (options?.type) {\n    result += `(${options.type}`;\n    if (options?.srid) {\n      result += `,${options.srid}`;\n    }\n\n    return `${result})`;\n  }\n  return `${result}(Geometry)`;\n};\n\nfunction toDriver(value: GeoJSON.Geometry) {\n  return sql`ST_GeomFromGeoJSON(${JSON.stringify(value)})`;\n}\n\n/** Internal function used for mapping Drizzle results\n * @internal\n */\nexport function fromDriver<T extends GeoJSON.Geometry>(value: string) {\n  const b = Buffer.from(value, \"hex\");\n  // Dependency on wkx can be removed once @link https://github.com/drizzle-team/drizzle-orm/pull/1423 is merged\n  return wkx.Geometry.parse(b).toGeoJSON({ shortCrs: true }) as T;\n}\n\n/** Internal function used for mapping Drizzle results\n *  @internal\n */\nexport function box2DfromDriver(value: string): GeoJSON.BBox {\n  const match = value.match(\n    /BOX\\((?<xmin>[0-9\\.]+),? ?(?<ymin>[0-9\\.]+),? ?(?<xmax>[0-9\\.]+),? ?(?<ymax>[0-9\\.]+)\\)/\n  );\n  if (!match?.groups) throw new Error(`Box2D parse error, value: ${value}`);\n  return [\n    Number.parseFloat(match.groups.xmin),\n    Number.parseFloat(match.groups.ymin),\n    Number.parseFloat(match.groups.xmax),\n    Number.parseFloat(match.groups.ymax),\n  ];\n}\n\n/** box2d is a spatial data type used to represent the two-dimensional bounding box enclosing a geometry or collection of geometries.\n *\n * The representation contains the values xmin, ymin, xmax, ymax. These are the minimum and maximum values of the X and Y extents.\n * @example `POINT (1 2)`\n *\n * @link https://postgis.net/docs/box2d_type.html\n */\nexport const box2D = customType<{\n  data: GeoJSON.Box2D;\n  driverData: string;\n}>({\n  dataType: () => \"box2d\",\n  toDriver: (b: GeoJSON.Box2D) => `BOX(${b[0]} ${b[1]}, ${b[2]} ${b[3]})`,\n  fromDriver: box2DfromDriver,\n});\n\n/** Geometry is a fundamental PostGIS spatial data type used to represent a feature in planar (Euclidean) coordinate systems.\n *\n * Geometry is an abstract type. Geometry values belong to one of its concrete subtypes which represent various kinds and dimensions of geometric shapes.\n * These include the atomic types Point, LineString, and Polygon,\n * and the collection types MultiPoint, MultiLineString, MultiPolygon and GeometryCollection.\n *\n * @link https://postgis.net/docs/geometry.html\n * @link https://postgis.net/docs/using_postgis_dbmanagement.html#OGC_Geometry\n */\nexport const geometry = customType<{\n  data: GeoJSON.Geometry;\n  config: GeometryOptions;\n  driverData: string;\n}>({\n  dataType,\n  toDriver: (pt: GeoJSON.Geometry) => toDriver(pt),\n  fromDriver: (value) => fromDriver<GeoJSON.Geometry>(value),\n});\n\n/** A Point is a 0-dimensional geometry that represents a single location in coordinate space.\n *\n * @example `POINT (1 2)`\n *\n * @link https://postgis.net/docs/using_postgis_dbmanagement.html#Point\n */\nexport const point = customType<{\n  data: GeoJSON.Point;\n  config: GeometrySubtypeOptions;\n  driverData: string;\n}>({\n  dataType: (options) =>\n    dataType({ type: `Point${options?.is3D ? \"Z\" : \"\"}`, ...options }),\n  toDriver: (pt: GeoJSON.Point) => toDriver(pt),\n  fromDriver: (value) => fromDriver<GeoJSON.Point>(value),\n});\n\n/** A MultiPoint is a collection of Points.\n *\n * @example `MULTIPOINT ( (0 0), (1 2) )`\n *\n * @link https://postgis.net/docs/using_postgis_dbmanagement.html#MultiPoint\n */\nexport const multiPoint = customType<{\n  data: GeoJSON.MultiPoint;\n  config: GeometrySubtypeOptions;\n  driverData: string;\n}>({\n  dataType: (options) =>\n    dataType({ type: `MultiPoint${options?.is3D ? \"Z\" : \"\"}`, ...options }),\n  toDriver: (pt: GeoJSON.MultiPoint) => toDriver(pt),\n  fromDriver: (value) => fromDriver<GeoJSON.MultiPoint>(value),\n});\n\n/** A LineString is a 1-dimensional line formed by a contiguous sequence of line segments.\n *\n * Each line segment is defined by two points, with the end point of one segment forming the start point of the next segment.\n * An OGC-valid LineString has either zero or two or more points, but PostGIS also allows single-point LineStrings.\n * LineStrings may cross themselves (self-intersect). A LineString is closed if the start and end points are the same.\n * A LineString is simple if it does not self-intersect.\n *\n * @example `LINESTRING (1 2, 3 4, 5 6)`\n *\n * @link https://postgis.net/docs/using_postgis_dbmanagement.html#LineString\n */\nexport const lineString = customType<{\n  data: GeoJSON.LineString;\n  config: GeometrySubtypeOptions;\n  driverData: string;\n}>({\n  dataType: (options) =>\n    dataType({ type: `LineString${options?.is3D ? \"Z\" : \"\"}`, ...options }),\n  toDriver: (pt: GeoJSON.LineString) => toDriver(pt),\n  fromDriver: (value) => fromDriver<GeoJSON.LineString>(value),\n});\n\n/** A MultiLineString is a collection of LineStrings.\n *\n * A MultiLineString is closed if each of its elements is closed.\n *\n * @example `MULTILINESTRING ( (0 0,1 1,1 2), (2 3,3 2,5 4) )`\n *\n * @link https://postgis.net/docs/using_postgis_dbmanagement.html#MultiLineString\n */\nexport const multiLineString = customType<{\n  data: GeoJSON.MultiLineString;\n  config: GeometrySubtypeOptions;\n  driverData: string;\n}>({\n  dataType: (options) =>\n    dataType({\n      type: `MultiLineString${options?.is3D ? \"Z\" : \"\"}`,\n      ...options,\n    }),\n  toDriver: (pt: GeoJSON.MultiLineString) => toDriver(pt),\n  fromDriver: (value) => fromDriver<GeoJSON.MultiLineString>(value),\n});\n\n/** A Polygon is a 2-dimensional planar region, delimited by an exterior boundary (the shell) and zero or more interior boundaries (holes).\n *\n * Each boundary is a LinearRing. A LinearRing is a LineString which is both closed and simple.\n * The first and last points must be equal, and the line must not self-intersect.\n *\n * @example `POLYGON ((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0))`\n *\n * @link https://postgis.net/docs/using_postgis_dbmanagement.html#Polygon\n */\nexport const polygon = customType<{\n  data: GeoJSON.Polygon;\n  config: GeometrySubtypeOptions;\n  driverData: string;\n}>({\n  dataType: (options) =>\n    dataType({ type: `Polygon${options?.is3D ? \"Z\" : \"\"}`, ...options }),\n  toDriver: (mp: GeoJSON.Polygon) => toDriver(mp),\n  fromDriver: (value) => fromDriver<GeoJSON.Polygon>(value),\n});\n\n/**\n * A MultiPolygon is a collection of non-overlapping, non-adjacent Polygons.\n *\n * Polygons in the collection may touch only at a finite number of points.\n *\n * @example `MULTIPOLYGON (((1 5, 5 5, 5 1, 1 1, 1 5)), ((6 5, 9 1, 6 1, 6 5)))`\n *\n * @link https://postgis.net/docs/using_postgis_dbmanagement.html#MultiPolygon\n */\nexport const multiPolygon = customType<{\n  data: GeoJSON.MultiPolygon;\n  config: GeometrySubtypeOptions;\n  driverData: string;\n}>({\n  dataType: (options) =>\n    dataType({ type: `MultiPolygon${options?.is3D ? \"Z\" : \"\"}`, ...options }),\n  toDriver: (mp: GeoJSON.MultiPolygon) => toDriver(mp),\n  fromDriver: (value) => fromDriver<GeoJSON.MultiPolygon>(value),\n});\n\n/** A GeometryCollection is a heterogeneous (mixed) collection of geometries.\n *\n * @example `GEOMETRYCOLLECTION ( POINT(2 3), LINESTRING(2 3, 3 4))`\n *\n * @link https://postgis.net/docs/using_postgis_dbmanagement.html#GeometryCollection\n */\nexport const geometryCollection = customType<{\n  data: GeoJSON.GeometryCollection;\n  config: Omit<GeometrySubtypeOptions, \"dimensions\">;\n  driverData: string;\n}>({\n  dataType: (options) =>\n    dataType({\n      type: \"GeometryCollection\",\n      ...options,\n    }),\n  toDriver: (mp: GeoJSON.GeometryCollection) => toDriver(mp),\n  fromDriver: (value) => fromDriver<GeoJSON.GeometryCollection>(value),\n});\n","export const entityKind = Symbol.for('drizzle:entityKind');\nexport const hasOwnEntityKind = Symbol.for('drizzle:hasOwnEntityKind');\n\nexport interface DrizzleEntity {\n\t[entityKind]: string;\n}\n\nexport type DrizzleEntityClass<T> =\n\t& ((abstract new(...args: any[]) => T) | (new(...args: any[]) => T))\n\t& DrizzleEntity;\n\nexport function is<T extends DrizzleEntityClass<any>>(value: any, type: T): value is InstanceType<T> {\n\tif (!value || typeof value !== 'object') {\n\t\treturn false;\n\t}\n\n\tif (value instanceof type) { // eslint-disable-line no-instanceof/no-instanceof\n\t\treturn true;\n\t}\n\n\tif (!Object.prototype.hasOwnProperty.call(type, entityKind)) {\n\t\tthrow new Error(\n\t\t\t`Class \"${\n\t\t\t\ttype.name ?? '<unknown>'\n\t\t\t}\" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`,\n\t\t);\n\t}\n\n\tlet cls = Object.getPrototypeOf(value).constructor;\n\tif (cls) {\n\t\t// Traverse the prototype chain to find the entityKind\n\t\twhile (cls) {\n\t\t\tif (entityKind in cls && cls[entityKind] === type[entityKind]) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tcls = Object.getPrototypeOf(cls);\n\t\t}\n\t}\n\n\treturn false;\n}\n","import type {\n\tColumnBuilderBaseConfig,\n\tColumnBuilderRuntimeConfig,\n\tColumnDataType,\n\tGeneratedColumnConfig,\n\tGeneratedIdentityConfig,\n} from './column-builder.ts';\nimport { entityKind } from './entity.ts';\nimport type { DriverValueMapper, SQL, SQLWrapper } from './sql/sql.ts';\nimport type { Table } from './table.ts';\nimport type { Update } from './utils.ts';\n\nexport interface ColumnBaseConfig<\n\tTDataType extends ColumnDataType,\n\tTColumnType extends string,\n> extends ColumnBuilderBaseConfig<TDataType, TColumnType> {\n\ttableName: string;\n\tnotNull: boolean;\n\thasDefault: boolean;\n\tisPrimaryKey: boolean;\n\tisAutoincrement: boolean;\n\thasRuntimeDefault: boolean;\n}\n\nexport type ColumnTypeConfig<T extends ColumnBaseConfig<ColumnDataType, string>, TTypeConfig extends object> = T & {\n\tbrand: 'Column';\n\ttableName: T['tableName'];\n\tname: T['name'];\n\tdataType: T['dataType'];\n\tcolumnType: T['columnType'];\n\tdata: T['data'];\n\tdriverParam: T['driverParam'];\n\tnotNull: T['notNull'];\n\thasDefault: T['hasDefault'];\n\tisPrimaryKey: T['isPrimaryKey'];\n\tisAutoincrement: T['isAutoincrement'];\n\thasRuntimeDefault: T['hasRuntimeDefault'];\n\tenumValues: T['enumValues'];\n\tbaseColumn: T extends { baseColumn: infer U } ? U : unknown;\n\tgenerated: GeneratedColumnConfig<T['data']> | undefined;\n\tidentity: undefined | 'always' | 'byDefault';\n} & TTypeConfig;\n\nexport type ColumnRuntimeConfig<TData, TRuntimeConfig extends object> = ColumnBuilderRuntimeConfig<\n\tTData,\n\tTRuntimeConfig\n>;\n\nexport interface Column<\n\tT extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTRuntimeConfig extends object = object,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTTypeConfig extends object = object,\n> extends DriverValueMapper<T['data'], T['driverParam']>, SQLWrapper {\n\t// SQLWrapper runtime implementation is defined in 'sql/sql.ts'\n}\n/*\n\t`Column` only accepts a full `ColumnConfig` as its generic.\n\tTo infer parts of the config, use `AnyColumn` that accepts a partial config.\n\tSee `GetColumnData` for example usage of inferring.\n*/\nexport abstract class Column<\n\tT extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = object,\n\tTTypeConfig extends object = object,\n> implements DriverValueMapper<T['data'], T['driverParam']>, SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Column';\n\n\tdeclare readonly _: ColumnTypeConfig<T, TTypeConfig>;\n\n\treadonly name: string;\n\treadonly keyAsName: boolean;\n\treadonly primary: boolean;\n\treadonly notNull: boolean;\n\treadonly default: T['data'] | SQL | undefined;\n\treadonly defaultFn: (() => T['data'] | SQL) | undefined;\n\treadonly onUpdateFn: (() => T['data'] | SQL) | undefined;\n\treadonly hasDefault: boolean;\n\treadonly isUnique: boolean;\n\treadonly uniqueName: string | undefined;\n\treadonly uniqueType: string | undefined;\n\treadonly dataType: T['dataType'];\n\treadonly columnType: T['columnType'];\n\treadonly enumValues: T['enumValues'] = undefined;\n\treadonly generated: GeneratedColumnConfig<T['data']> | undefined = undefined;\n\treadonly generatedIdentity: GeneratedIdentityConfig | undefined = undefined;\n\n\tprotected config: ColumnRuntimeConfig<T['data'], TRuntimeConfig>;\n\n\tconstructor(\n\t\treadonly table: Table,\n\t\tconfig: ColumnRuntimeConfig<T['data'], TRuntimeConfig>,\n\t) {\n\t\tthis.config = config;\n\t\tthis.name = config.name;\n\t\tthis.keyAsName = config.keyAsName;\n\t\tthis.notNull = config.notNull;\n\t\tthis.default = config.default;\n\t\tthis.defaultFn = config.defaultFn;\n\t\tthis.onUpdateFn = config.onUpdateFn;\n\t\tthis.hasDefault = config.hasDefault;\n\t\tthis.primary = config.primaryKey;\n\t\tthis.isUnique = config.isUnique;\n\t\tthis.uniqueName = config.uniqueName;\n\t\tthis.uniqueType = config.uniqueType;\n\t\tthis.dataType = config.dataType as T['dataType'];\n\t\tthis.columnType = config.columnType;\n\t\tthis.generated = config.generated;\n\t\tthis.generatedIdentity = config.generatedIdentity;\n\t}\n\n\tabstract getSQLType(): string;\n\n\tmapFromDriverValue(value: unknown): unknown {\n\t\treturn value;\n\t}\n\n\tmapToDriverValue(value: unknown): unknown {\n\t\treturn value;\n\t}\n\n\t// ** @internal */\n\tshouldDisableInsert(): boolean {\n\t\treturn this.config.generated !== undefined && this.config.generated.type !== 'byDefault';\n\t}\n}\n\nexport type UpdateColConfig<\n\tT extends ColumnBaseConfig<ColumnDataType, string>,\n\tTUpdate extends Partial<ColumnBaseConfig<ColumnDataType, string>>,\n> = Update<T, TUpdate>;\n\nexport type AnyColumn<TPartial extends Partial<ColumnBaseConfig<ColumnDataType, string>> = {}> = Column<\n\tRequired<Update<ColumnBaseConfig<ColumnDataType, string>, TPartial>>\n>;\n\nexport type GetColumnData<TColumn extends Column, TInferMode extends 'query' | 'raw' = 'query'> =\n\t// dprint-ignore\n\tTInferMode extends 'raw' // Raw mode\n\t\t? TColumn['_']['data'] // Just return the underlying type\n\t\t: TColumn['_']['notNull'] extends true // Query mode\n\t\t? TColumn['_']['data'] // Query mode, not null\n\t\t: TColumn['_']['data'] | null; // Query mode, nullable\n\nexport type InferColumnsDataTypes<TColumns extends Record<string, Column>> = {\n\t[Key in keyof TColumns]: GetColumnData<TColumns[Key], 'query'>;\n};\n","import { entityKind } from '~/entity.ts';\nimport type { Column } from './column.ts';\nimport type { GelColumn, GelExtraConfigColumn } from './gel-core/index.ts';\nimport type { MySqlColumn } from './mysql-core/index.ts';\nimport type { ExtraConfigColumn, PgColumn, PgSequenceOptions } from './pg-core/index.ts';\nimport type { SingleStoreColumn } from './singlestore-core/index.ts';\nimport type { SQL } from './sql/sql.ts';\nimport type { SQLiteColumn } from './sqlite-core/index.ts';\nimport type { Assume, Simplify } from './utils.ts';\n\nexport type ColumnDataType =\n\t| 'string'\n\t| 'number'\n\t| 'boolean'\n\t| 'array'\n\t| 'json'\n\t| 'date'\n\t| 'bigint'\n\t| 'custom'\n\t| 'buffer'\n\t| 'dateDuration'\n\t| 'duration'\n\t| 'relDuration'\n\t| 'localTime'\n\t| 'localDate'\n\t| 'localDateTime';\n\nexport type Dialect = 'pg' | 'mysql' | 'sqlite' | 'singlestore' | 'common' | 'gel';\n\nexport type GeneratedStorageMode = 'virtual' | 'stored';\n\nexport type GeneratedType = 'always' | 'byDefault';\n\nexport type GeneratedColumnConfig<TDataType> = {\n\tas: TDataType | SQL | (() => SQL);\n\ttype?: GeneratedType;\n\tmode?: GeneratedStorageMode;\n};\n\nexport type GeneratedIdentityConfig = {\n\tsequenceName?: string;\n\tsequenceOptions?: PgSequenceOptions;\n\ttype: 'always' | 'byDefault';\n};\n\nexport interface ColumnBuilderBaseConfig<TDataType extends ColumnDataType, TColumnType extends string> {\n\tname: string;\n\tdataType: TDataType;\n\tcolumnType: TColumnType;\n\tdata: unknown;\n\tdriverParam: unknown;\n\tenumValues: string[] | undefined;\n}\n\nexport type MakeColumnConfig<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTTableName extends string,\n\tTData = T extends { $type: infer U } ? U : T['data'],\n> = {\n\tname: T['name'];\n\ttableName: TTableName;\n\tdataType: T['dataType'];\n\tcolumnType: T['columnType'];\n\tdata: TData;\n\tdriverParam: T['driverParam'];\n\tnotNull: T extends { notNull: true } ? true : false;\n\thasDefault: T extends { hasDefault: true } ? true : false;\n\tisPrimaryKey: T extends { isPrimaryKey: true } ? true : false;\n\tisAutoincrement: T extends { isAutoincrement: true } ? true : false;\n\thasRuntimeDefault: T extends { hasRuntimeDefault: true } ? true : false;\n\tenumValues: T['enumValues'];\n\tbaseColumn: T extends { baseBuilder: infer U extends ColumnBuilderBase } ? BuildColumn<TTableName, U, 'common'>\n\t\t: never;\n\tidentity: T extends { identity: 'always' } ? 'always' : T extends { identity: 'byDefault' } ? 'byDefault' : undefined;\n\tgenerated: T extends { generated: infer G } ? unknown extends G ? undefined\n\t\t: G extends undefined ? undefined\n\t\t: G\n\t\t: undefined;\n} & {};\n\nexport type ColumnBuilderTypeConfig<\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTTypeConfig extends object = object,\n> = Simplify<\n\t& {\n\t\tbrand: 'ColumnBuilder';\n\t\tname: T['name'];\n\t\tdataType: T['dataType'];\n\t\tcolumnType: T['columnType'];\n\t\tdata: T['data'];\n\t\tdriverParam: T['driverParam'];\n\t\tnotNull: T extends { notNull: infer U } ? U : boolean;\n\t\thasDefault: T extends { hasDefault: infer U } ? U : boolean;\n\t\tenumValues: T['enumValues'];\n\t\tidentity: T extends { identity: infer U } ? U : unknown;\n\t\tgenerated: T extends { generated: infer G } ? G extends undefined ? unknown : G : unknown;\n\t}\n\t& TTypeConfig\n>;\n\nexport type ColumnBuilderRuntimeConfig<TData, TRuntimeConfig extends object = object> = {\n\tname: string;\n\tkeyAsName: boolean;\n\tnotNull: boolean;\n\tdefault: TData | SQL | undefined;\n\tdefaultFn: (() => TData | SQL) | undefined;\n\tonUpdateFn: (() => TData | SQL) | undefined;\n\thasDefault: boolean;\n\tprimaryKey: boolean;\n\tisUnique: boolean;\n\tuniqueName: string | undefined;\n\tuniqueType: string | undefined;\n\tdataType: string;\n\tcolumnType: string;\n\tgenerated: GeneratedColumnConfig<TData> | undefined;\n\tgeneratedIdentity: GeneratedIdentityConfig | undefined;\n} & TRuntimeConfig;\n\nexport interface ColumnBuilderExtraConfig {\n\tprimaryKeyHasDefault?: boolean;\n}\n\nexport type NotNull<T extends ColumnBuilderBase> = T & {\n\t_: {\n\t\tnotNull: true;\n\t};\n};\n\nexport type HasDefault<T extends ColumnBuilderBase> = T & {\n\t_: {\n\t\thasDefault: true;\n\t};\n};\n\nexport type IsPrimaryKey<T extends ColumnBuilderBase> = T & {\n\t_: {\n\t\tisPrimaryKey: true;\n\t};\n};\n\nexport type IsAutoincrement<T extends ColumnBuilderBase> = T & {\n\t_: {\n\t\tisAutoincrement: true;\n\t};\n};\n\nexport type HasRuntimeDefault<T extends ColumnBuilderBase> = T & {\n\t_: {\n\t\thasRuntimeDefault: true;\n\t};\n};\n\nexport type $Type<T extends ColumnBuilderBase, TType> = T & {\n\t_: {\n\t\t$type: TType;\n\t};\n};\n\nexport type HasGenerated<T extends ColumnBuilderBase, TGenerated extends {} = {}> = T & {\n\t_: {\n\t\thasDefault: true;\n\t\tgenerated: TGenerated;\n\t};\n};\n\nexport type IsIdentity<\n\tT extends ColumnBuilderBase,\n\tTType extends 'always' | 'byDefault',\n> = T & {\n\t_: {\n\t\tnotNull: true;\n\t\thasDefault: true;\n\t\tidentity: TType;\n\t};\n};\nexport interface ColumnBuilderBase<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTTypeConfig extends object = object,\n> {\n\t_: ColumnBuilderTypeConfig<T, TTypeConfig>;\n}\n\n// To understand how to use `ColumnBuilder` and `AnyColumnBuilder`, see `Column` and `AnyColumn` documentation.\nexport abstract class ColumnBuilder<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = object,\n\tTTypeConfig extends object = object,\n\tTExtraConfig extends ColumnBuilderExtraConfig = ColumnBuilderExtraConfig,\n> implements ColumnBuilderBase<T, TTypeConfig> {\n\tstatic readonly [entityKind]: string = 'ColumnBuilder';\n\n\tdeclare _: ColumnBuilderTypeConfig<T, TTypeConfig>;\n\n\tprotected config: ColumnBuilderRuntimeConfig<T['data'], TRuntimeConfig>;\n\n\tconstructor(name: T['name'], dataType: T['dataType'], columnType: T['columnType']) {\n\t\tthis.config = {\n\t\t\tname,\n\t\t\tkeyAsName: name === '',\n\t\t\tnotNull: false,\n\t\t\tdefault: undefined,\n\t\t\thasDefault: false,\n\t\t\tprimaryKey: false,\n\t\t\tisUnique: false,\n\t\t\tuniqueName: undefined,\n\t\t\tuniqueType: undefined,\n\t\t\tdataType,\n\t\t\tcolumnType,\n\t\t\tgenerated: undefined,\n\t\t} as ColumnBuilderRuntimeConfig<T['data'], TRuntimeConfig>;\n\t}\n\n\t/**\n\t * Changes the data type of the column. Commonly used with `json` columns. Also, useful for branded types.\n\t *\n\t * @example\n\t * ```ts\n\t * const users = pgTable('users', {\n\t * \tid: integer('id').$type<UserId>().primaryKey(),\n\t * \tdetails: json('details').$type<UserDetails>().notNull(),\n\t * });\n\t * ```\n\t */\n\t$type<TType>(): $Type<this, TType> {\n\t\treturn this as $Type<this, TType>;\n\t}\n\n\t/**\n\t * Adds a `not null` clause to the column definition.\n\t *\n\t * Affects the `select` model of the table - columns *without* `not null` will be nullable on select.\n\t */\n\tnotNull(): NotNull<this> {\n\t\tthis.config.notNull = true;\n\t\treturn this as NotNull<this>;\n\t}\n\n\t/**\n\t * Adds a `default <value>` clause to the column definition.\n\t *\n\t * Affects the `insert` model of the table - columns *with* `default` are optional on insert.\n\t *\n\t * If you need to set a dynamic default value, use {@link $defaultFn} instead.\n\t */\n\tdefault(value: (this['_'] extends { $type: infer U } ? U : this['_']['data']) | SQL): HasDefault<this> {\n\t\tthis.config.default = value;\n\t\tthis.config.hasDefault = true;\n\t\treturn this as HasDefault<this>;\n\t}\n\n\t/**\n\t * Adds a dynamic default value to the column.\n\t * The function will be called when the row is inserted, and the returned value will be used as the column value.\n\t *\n\t * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.\n\t */\n\t$defaultFn(\n\t\tfn: () => (this['_'] extends { $type: infer U } ? U : this['_']['data']) | SQL,\n\t): HasRuntimeDefault<HasDefault<this>> {\n\t\tthis.config.defaultFn = fn;\n\t\tthis.config.hasDefault = true;\n\t\treturn this as HasRuntimeDefault<HasDefault<this>>;\n\t}\n\n\t/**\n\t * Alias for {@link $defaultFn}.\n\t */\n\t$default = this.$defaultFn;\n\n\t/**\n\t * Adds a dynamic update value to the column.\n\t * The function will be called when the row is updated, and the returned value will be used as the column value if none is provided.\n\t * If no `default` (or `$defaultFn`) value is provided, the function will be called when the row is inserted as well, and the returned value will be used as the column value.\n\t *\n\t * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.\n\t */\n\t$onUpdateFn(\n\t\tfn: () => (this['_'] extends { $type: infer U } ? U : this['_']['data']) | SQL,\n\t): HasDefault<this> {\n\t\tthis.config.onUpdateFn = fn;\n\t\tthis.config.hasDefault = true;\n\t\treturn this as HasDefault<this>;\n\t}\n\n\t/**\n\t * Alias for {@link $onUpdateFn}.\n\t */\n\t$onUpdate = this.$onUpdateFn;\n\n\t/**\n\t * Adds a `primary key` clause to the column definition. This implicitly makes the column `not null`.\n\t *\n\t * In SQLite, `integer primary key` implicitly makes the column auto-incrementing.\n\t */\n\tprimaryKey(): TExtraConfig['primaryKeyHasDefault'] extends true ? IsPrimaryKey<HasDefault<NotNull<this>>>\n\t\t: IsPrimaryKey<NotNull<this>>\n\t{\n\t\tthis.config.primaryKey = true;\n\t\tthis.config.notNull = true;\n\t\treturn this as TExtraConfig['primaryKeyHasDefault'] extends true ? IsPrimaryKey<HasDefault<NotNull<this>>>\n\t\t\t: IsPrimaryKey<NotNull<this>>;\n\t}\n\n\tabstract generatedAlwaysAs(\n\t\tas: SQL | T['data'] | (() => SQL),\n\t\tconfig?: Partial<GeneratedColumnConfig<unknown>>,\n\t): HasGenerated<this, {\n\t\ttype: 'always';\n\t}>;\n\n\t/** @internal Sets the name of the column to the key within the table definition if a name was not given. */\n\tsetName(name: string) {\n\t\tif (this.config.name !== '') return;\n\t\tthis.config.name = name;\n\t}\n}\n\nexport type BuildColumn<\n\tTTableName extends string,\n\tTBuilder extends ColumnBuilderBase,\n\tTDialect extends Dialect,\n> = TDialect extends 'pg' ? PgColumn<\n\t\tMakeColumnConfig<TBuilder['_'], TTableName>,\n\t\t{},\n\t\tSimplify<Omit<TBuilder['_'], keyof MakeColumnConfig<TBuilder['_'], TTableName> | 'brand' | 'dialect'>>\n\t>\n\t: TDialect extends 'mysql' ? MySqlColumn<\n\t\t\tMakeColumnConfig<TBuilder['_'], TTableName>,\n\t\t\t{},\n\t\t\tSimplify<\n\t\t\t\tOmit<\n\t\t\t\t\tTBuilder['_'],\n\t\t\t\t\t| keyof MakeColumnConfig<TBuilder['_'], TTableName>\n\t\t\t\t\t| 'brand'\n\t\t\t\t\t| 'dialect'\n\t\t\t\t\t| 'primaryKeyHasDefault'\n\t\t\t\t\t| 'mysqlColumnBuilderBrand'\n\t\t\t\t>\n\t\t\t>\n\t\t>\n\t: TDialect extends 'sqlite' ? SQLiteColumn<\n\t\t\tMakeColumnConfig<TBuilder['_'], TTableName>,\n\t\t\t{},\n\t\t\tSimplify<Omit<TBuilder['_'], keyof MakeColumnConfig<TBuilder['_'], TTableName> | 'brand' | 'dialect'>>\n\t\t>\n\t: TDialect extends 'common' ? Column<\n\t\t\tMakeColumnConfig<TBuilder['_'], TTableName>,\n\t\t\t{},\n\t\t\tSimplify<Omit<TBuilder['_'], keyof MakeColumnConfig<TBuilder['_'], TTableName> | 'brand' | 'dialect'>>\n\t\t>\n\t: TDialect extends 'singlestore' ? SingleStoreColumn<\n\t\t\tMakeColumnConfig<TBuilder['_'], TTableName>,\n\t\t\t{},\n\t\t\tSimplify<\n\t\t\t\tOmit<\n\t\t\t\t\tTBuilder['_'],\n\t\t\t\t\t| keyof MakeColumnConfig<TBuilder['_'], TTableName>\n\t\t\t\t\t| 'brand'\n\t\t\t\t\t| 'dialect'\n\t\t\t\t\t| 'primaryKeyHasDefault'\n\t\t\t\t\t| 'singlestoreColumnBuilderBrand'\n\t\t\t\t>\n\t\t\t>\n\t\t>\n\t: TDialect extends 'gel' ? GelColumn<\n\t\t\tMakeColumnConfig<TBuilder['_'], TTableName>,\n\t\t\t{},\n\t\t\tSimplify<Omit<TBuilder['_'], keyof MakeColumnConfig<TBuilder['_'], TTableName> | 'brand' | 'dialect'>>\n\t\t>\n\t: never;\n\nexport type BuildIndexColumn<\n\tTDialect extends Dialect,\n> = TDialect extends 'pg' ? ExtraConfigColumn\n\t: TDialect extends 'gel' ? GelExtraConfigColumn\n\t: never;\n\n// TODO\n// try to make sql as well + indexRaw\n\n// optional after everything will be working as expected\n// also try to leave only needed methods for extraConfig\n// make an error if I pass .asc() to fk and so on\n\nexport type BuildColumns<\n\tTTableName extends string,\n\tTConfigMap extends Record<string, ColumnBuilderBase>,\n\tTDialect extends Dialect,\n> =\n\t& {\n\t\t[Key in keyof TConfigMap]: BuildColumn<TTableName, {\n\t\t\t_:\n\t\t\t\t& Omit<TConfigMap[Key]['_'], 'name'>\n\t\t\t\t& { name: TConfigMap[Key]['_']['name'] extends '' ? Assume<Key, string> : TConfigMap[Key]['_']['name'] };\n\t\t}, TDialect>;\n\t}\n\t& {};\n\nexport type BuildExtraConfigColumns<\n\t_TTableName extends string,\n\tTConfigMap extends Record<string, ColumnBuilderBase>,\n\tTDialect extends Dialect,\n> =\n\t& {\n\t\t[Key in keyof TConfigMap]: BuildIndexColumn<TDialect>;\n\t}\n\t& {};\n\nexport type ChangeColumnTableName<TColumn extends Column, TAlias extends string, TDialect extends Dialect> =\n\tTDialect extends 'pg' ? PgColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: TDialect extends 'mysql' ? MySqlColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: TDialect extends 'singlestore' ? SingleStoreColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: TDialect extends 'sqlite' ? SQLiteColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: TDialect extends 'gel' ? GelColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: never;\n","/** @internal */\nexport const TableName = Symbol.for('drizzle:Name');\n","import { entityKind } from '~/entity.ts';\nimport { TableName } from '~/table.utils.ts';\nimport type { AnyPgColumn, PgColumn } from './columns/index.ts';\nimport type { PgTable } from './table.ts';\n\nexport type UpdateDeleteAction = 'cascade' | 'restrict' | 'no action' | 'set null' | 'set default';\n\nexport type Reference = () => {\n\treadonly name?: string;\n\treadonly columns: PgColumn[];\n\treadonly foreignTable: PgTable;\n\treadonly foreignColumns: PgColumn[];\n};\n\nexport class ForeignKeyBuilder {\n\tstatic readonly [entityKind]: string = 'PgForeignKeyBuilder';\n\n\t/** @internal */\n\treference: Reference;\n\n\t/** @internal */\n\t_onUpdate: UpdateDeleteAction | undefined = 'no action';\n\n\t/** @internal */\n\t_onDelete: UpdateDeleteAction | undefined = 'no action';\n\n\tconstructor(\n\t\tconfig: () => {\n\t\t\tname?: string;\n\t\t\tcolumns: PgColumn[];\n\t\t\tforeignColumns: PgColumn[];\n\t\t},\n\t\tactions?: {\n\t\t\tonUpdate?: UpdateDeleteAction;\n\t\t\tonDelete?: UpdateDeleteAction;\n\t\t} | undefined,\n\t) {\n\t\tthis.reference = () => {\n\t\t\tconst { name, columns, foreignColumns } = config();\n\t\t\treturn { name, columns, foreignTable: foreignColumns[0]!.table as PgTable, foreignColumns };\n\t\t};\n\t\tif (actions) {\n\t\t\tthis._onUpdate = actions.onUpdate;\n\t\t\tthis._onDelete = actions.onDelete;\n\t\t}\n\t}\n\n\tonUpdate(action: UpdateDeleteAction): this {\n\t\tthis._onUpdate = action === undefined ? 'no action' : action;\n\t\treturn this;\n\t}\n\n\tonDelete(action: UpdateDeleteAction): this {\n\t\tthis._onDelete = action === undefined ? 'no action' : action;\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tbuild(table: PgTable): ForeignKey {\n\t\treturn new ForeignKey(table, this);\n\t}\n}\n\nexport type AnyForeignKeyBuilder = ForeignKeyBuilder;\n\nexport class ForeignKey {\n\tstatic readonly [entityKind]: string = 'PgForeignKey';\n\n\treadonly reference: Reference;\n\treadonly onUpdate: UpdateDeleteAction | undefined;\n\treadonly onDelete: UpdateDeleteAction | undefined;\n\n\tconstructor(readonly table: PgTable, builder: ForeignKeyBuilder) {\n\t\tthis.reference = builder.reference;\n\t\tthis.onUpdate = builder._onUpdate;\n\t\tthis.onDelete = builder._onDelete;\n\t}\n\n\tgetName(): string {\n\t\tconst { name, columns, foreignColumns } = this.reference();\n\t\tconst columnNames = columns.map((column) => column.name);\n\t\tconst foreignColumnNames = foreignColumns.map((column) => column.name);\n\t\tconst chunks = [\n\t\t\tthis.table[TableName],\n\t\t\t...columnNames,\n\t\t\tforeignColumns[0]!.table[TableName],\n\t\t\t...foreignColumnNames,\n\t\t];\n\t\treturn name ?? `${chunks.join('_')}_fk`;\n\t}\n}\n\ntype ColumnsWithTable<\n\tTTableName extends string,\n\tTColumns extends PgColumn[],\n> = { [Key in keyof TColumns]: AnyPgColumn<{ tableName: TTableName }> };\n\nexport function foreignKey<\n\tTTableName extends string,\n\tTForeignTableName extends string,\n\tTColumns extends [AnyPgColumn<{ tableName: TTableName }>, ...AnyPgColumn<{ tableName: TTableName }>[]],\n>(\n\tconfig: {\n\t\tname?: string;\n\t\tcolumns: TColumns;\n\t\tforeignColumns: ColumnsWithTable<TForeignTableName, TColumns>;\n\t},\n): ForeignKeyBuilder {\n\tfunction mappedConfig() {\n\t\tconst { name, columns, foreignColumns } = config;\n\t\treturn {\n\t\t\tname,\n\t\t\tcolumns,\n\t\t\tforeignColumns,\n\t\t};\n\t}\n\n\treturn new ForeignKeyBuilder(mappedConfig);\n}\n","export function iife<T extends unknown[], U>(fn: (...args: T) => U, ...args: T): U {\n\treturn fn(...args);\n}\n","import { entityKind } from '~/entity.ts';\nimport { TableName } from '~/table.utils.ts';\nimport type { PgColumn } from './columns/index.ts';\nimport type { PgTable } from './table.ts';\n\nexport function unique(name?: string): UniqueOnConstraintBuilder {\n\treturn new UniqueOnConstraintBuilder(name);\n}\n\nexport function uniqueKeyName(table: PgTable, columns: string[]) {\n\treturn `${table[TableName]}_${columns.join('_')}_unique`;\n}\n\nexport class UniqueConstraintBuilder {\n\tstatic readonly [entityKind]: string = 'PgUniqueConstraintBuilder';\n\n\t/** @internal */\n\tcolumns: PgColumn[];\n\t/** @internal */\n\tnullsNotDistinctConfig = false;\n\n\tconstructor(\n\t\tcolumns: PgColumn[],\n\t\tprivate name?: string,\n\t) {\n\t\tthis.columns = columns;\n\t}\n\n\tnullsNotDistinct() {\n\t\tthis.nullsNotDistinctConfig = true;\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tbuild(table: PgTable): UniqueConstraint {\n\t\treturn new UniqueConstraint(table, this.columns, this.nullsNotDistinctConfig, this.name);\n\t}\n}\n\nexport class UniqueOnConstraintBuilder {\n\tstatic readonly [entityKind]: string = 'PgUniqueOnConstraintBuilder';\n\n\t/** @internal */\n\tname?: string;\n\n\tconstructor(\n\t\tname?: string,\n\t) {\n\t\tthis.name = name;\n\t}\n\n\ton(...columns: [PgColumn, ...PgColumn[]]) {\n\t\treturn new UniqueConstraintBuilder(columns, this.name);\n\t}\n}\n\nexport class UniqueConstraint {\n\tstatic readonly [entityKind]: string = 'PgUniqueConstraint';\n\n\treadonly columns: PgColumn[];\n\treadonly name?: string;\n\treadonly nullsNotDistinct: boolean = false;\n\n\tconstructor(readonly table: PgTable, columns: PgColumn[], nullsNotDistinct: boolean, name?: string) {\n\t\tthis.columns = columns;\n\t\tthis.name = name ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));\n\t\tthis.nullsNotDistinct = nullsNotDistinct;\n\t}\n\n\tgetName() {\n\t\treturn this.name;\n\t}\n}\n","function parsePgArrayValue(arrayString: string, startFrom: number, inQuotes: boolean): [string, number] {\n\tfor (let i = startFrom; i < arrayString.length; i++) {\n\t\tconst char = arrayString[i];\n\n\t\tif (char === '\\\\') {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === '\"') {\n\t\t\treturn [arrayString.slice(startFrom, i).replace(/\\\\/g, ''), i + 1];\n\t\t}\n\n\t\tif (inQuotes) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === ',' || char === '}') {\n\t\t\treturn [arrayString.slice(startFrom, i).replace(/\\\\/g, ''), i];\n\t\t}\n\t}\n\n\treturn [arrayString.slice(startFrom).replace(/\\\\/g, ''), arrayString.length];\n}\n\nexport function parsePgNestedArray(arrayString: string, startFrom = 0): [any[], number] {\n\tconst result: any[] = [];\n\tlet i = startFrom;\n\tlet lastCharIsComma = false;\n\n\twhile (i < arrayString.length) {\n\t\tconst char = arrayString[i];\n\n\t\tif (char === ',') {\n\t\t\tif (lastCharIsComma || i === startFrom) {\n\t\t\t\tresult.push('');\n\t\t\t}\n\t\t\tlastCharIsComma = true;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlastCharIsComma = false;\n\n\t\tif (char === '\\\\') {\n\t\t\ti += 2;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === '\"') {\n\t\t\tconst [value, startFrom] = parsePgArrayValue(arrayString, i + 1, true);\n\t\t\tresult.push(value);\n\t\t\ti = startFrom;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === '}') {\n\t\t\treturn [result, i + 1];\n\t\t}\n\n\t\tif (char === '{') {\n\t\t\tconst [value, startFrom] = parsePgNestedArray(arrayString, i + 1);\n\t\t\tresult.push(value);\n\t\t\ti = startFrom;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst [value, newStartFrom] = parsePgArrayValue(arrayString, i, false);\n\t\tresult.push(value);\n\t\ti = newStartFrom;\n\t}\n\n\treturn [result, i];\n}\n\nexport function parsePgArray(arrayString: string): any[] {\n\tconst [result] = parsePgNestedArray(arrayString, 1);\n\treturn result;\n}\n\nexport function makePgArray(array: any[]): string {\n\treturn `{${\n\t\tarray.map((item) => {\n\t\t\tif (Array.isArray(item)) {\n\t\t\t\treturn makePgArray(item);\n\t\t\t}\n\n\t\t\tif (typeof item === 'string') {\n\t\t\t\treturn `\"${item.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"')}\"`;\n\t\t\t}\n\n\t\t\treturn `${item}`;\n\t\t}).join(',')\n\t}}`;\n}\n","import type {\n\tColumnBuilderBase,\n\tColumnBuilderBaseConfig,\n\tColumnBuilderExtraConfig,\n\tColumnBuilderRuntimeConfig,\n\tColumnDataType,\n\tHasGenerated,\n\tMakeColumnConfig,\n} from '~/column-builder.ts';\nimport { ColumnBuilder } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { Column } from '~/column.ts';\nimport { entityKind, is } from '~/entity.ts';\nimport type { Simplify, Update } from '~/utils.ts';\n\nimport type { ForeignKey, UpdateDeleteAction } from '~/pg-core/foreign-keys.ts';\nimport { ForeignKeyBuilder } from '~/pg-core/foreign-keys.ts';\nimport type { AnyPgTable, PgTable } from '~/pg-core/table.ts';\nimport type { SQL } from '~/sql/sql.ts';\nimport { iife } from '~/tracing-utils.ts';\nimport type { PgIndexOpClass } from '../indexes.ts';\nimport { uniqueKeyName } from '../unique-constraint.ts';\nimport { makePgArray, parsePgArray } from '../utils/array.ts';\n\nexport interface ReferenceConfig {\n\tref: () => PgColumn;\n\tactions: {\n\t\tonUpdate?: UpdateDeleteAction;\n\t\tonDelete?: UpdateDeleteAction;\n\t};\n}\n\nexport interface PgColumnBuilderBase<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTTypeConfig extends object = object,\n> extends ColumnBuilderBase<T, TTypeConfig & { dialect: 'pg' }> {}\n\nexport abstract class PgColumnBuilder<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = object,\n\tTTypeConfig extends object = object,\n\tTExtraConfig extends ColumnBuilderExtraConfig = ColumnBuilderExtraConfig,\n> extends ColumnBuilder<T, TRuntimeConfig, TTypeConfig & { dialect: 'pg' }, TExtraConfig>\n\timplements PgColumnBuilderBase<T, TTypeConfig>\n{\n\tprivate foreignKeyConfigs: ReferenceConfig[] = [];\n\n\tstatic override readonly [entityKind]: string = 'PgColumnBuilder';\n\n\tarray<TSize extends number | undefined = undefined>(size?: TSize): PgArrayBuilder<\n\t\t& {\n\t\t\tname: T['name'];\n\t\t\tdataType: 'array';\n\t\t\tcolumnType: 'PgArray';\n\t\t\tdata: T['data'][];\n\t\t\tdriverParam: T['driverParam'][] | string;\n\t\t\tenumValues: T['enumValues'];\n\t\t\tsize: TSize;\n\t\t\tbaseBuilder: T;\n\t\t}\n\t\t& (T extends { notNull: true } ? { notNull: true } : {})\n\t\t& (T extends { hasDefault: true } ? { hasDefault: true } : {}),\n\t\tT\n\t> {\n\t\treturn new PgArrayBuilder(this.config.name, this as PgColumnBuilder<any, any>, size as any);\n\t}\n\n\treferences(\n\t\tref: ReferenceConfig['ref'],\n\t\tactions: ReferenceConfig['actions'] = {},\n\t): this {\n\t\tthis.foreignKeyConfigs.push({ ref, actions });\n\t\treturn this;\n\t}\n\n\tunique(\n\t\tname?: string,\n\t\tconfig?: { nulls: 'distinct' | 'not distinct' },\n\t): this {\n\t\tthis.config.isUnique = true;\n\t\tthis.config.uniqueName = name;\n\t\tthis.config.uniqueType = config?.nulls;\n\t\treturn this;\n\t}\n\n\tgeneratedAlwaysAs(as: SQL | T['data'] | (() => SQL)): HasGenerated<this, {\n\t\ttype: 'always';\n\t}> {\n\t\tthis.config.generated = {\n\t\t\tas,\n\t\t\ttype: 'always',\n\t\t\tmode: 'stored',\n\t\t};\n\t\treturn this as HasGenerated<this, {\n\t\t\ttype: 'always';\n\t\t}>;\n\t}\n\n\t/** @internal */\n\tbuildForeignKeys(column: PgColumn, table: PgTable): ForeignKey[] {\n\t\treturn this.foreignKeyConfigs.map(({ ref, actions }) => {\n\t\t\treturn iife(\n\t\t\t\t(ref, actions) => {\n\t\t\t\t\tconst builder = new ForeignKeyBuilder(() => {\n\t\t\t\t\t\tconst foreignColumn = ref();\n\t\t\t\t\t\treturn { columns: [column], foreignColumns: [foreignColumn] };\n\t\t\t\t\t});\n\t\t\t\t\tif (actions.onUpdate) {\n\t\t\t\t\t\tbuilder.onUpdate(actions.onUpdate);\n\t\t\t\t\t}\n\t\t\t\t\tif (actions.onDelete) {\n\t\t\t\t\t\tbuilder.onDelete(actions.onDelete);\n\t\t\t\t\t}\n\t\t\t\t\treturn builder.build(table);\n\t\t\t\t},\n\t\t\t\tref,\n\t\t\t\tactions,\n\t\t\t);\n\t\t});\n\t}\n\n\t/** @internal */\n\tabstract build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgColumn<MakeColumnConfig<T, TTableName>>;\n\n\t/** @internal */\n\tbuildExtraConfigColumn<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): ExtraConfigColumn {\n\t\treturn new ExtraConfigColumn(table, this.config);\n\t}\n}\n\n// To understand how to use `PgColumn` and `PgColumn`, see `Column` and `AnyColumn` documentation.\nexport abstract class PgColumn<\n\tT extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = {},\n\tTTypeConfig extends object = {},\n> extends Column<T, TRuntimeConfig, TTypeConfig & { dialect: 'pg' }> {\n\tstatic override readonly [entityKind]: string = 'PgColumn';\n\n\tconstructor(\n\t\toverride readonly table: PgTable,\n\t\tconfig: ColumnBuilderRuntimeConfig<T['data'], TRuntimeConfig>,\n\t) {\n\t\tif (!config.uniqueName) {\n\t\t\tconfig.uniqueName = uniqueKeyName(table, [config.name]);\n\t\t}\n\t\tsuper(table, config);\n\t}\n}\n\nexport type IndexedExtraConfigType = { order?: 'asc' | 'desc'; nulls?: 'first' | 'last'; opClass?: string };\n\nexport class ExtraConfigColumn<\n\tT extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>,\n> extends PgColumn<T, IndexedExtraConfigType> {\n\tstatic override readonly [entityKind]: string = 'ExtraConfigColumn';\n\n\toverride getSQLType(): string {\n\t\treturn this.getSQLType();\n\t}\n\n\tindexConfig: IndexedExtraConfigType = {\n\t\torder: this.config.order ?? 'asc',\n\t\tnulls: this.config.nulls ?? 'last',\n\t\topClass: this.config.opClass,\n\t};\n\tdefaultConfig: IndexedExtraConfigType = {\n\t\torder: 'asc',\n\t\tnulls: 'last',\n\t\topClass: undefined,\n\t};\n\n\tasc(): Omit<this, 'asc' | 'desc'> {\n\t\tthis.indexConfig.order = 'asc';\n\t\treturn this;\n\t}\n\n\tdesc(): Omit<this, 'asc' | 'desc'> {\n\t\tthis.indexConfig.order = 'desc';\n\t\treturn this;\n\t}\n\n\tnullsFirst(): Omit<this, 'nullsFirst' | 'nullsLast'> {\n\t\tthis.indexConfig.nulls = 'first';\n\t\treturn this;\n\t}\n\n\tnullsLast(): Omit<this, 'nullsFirst' | 'nullsLast'> {\n\t\tthis.indexConfig.nulls = 'last';\n\t\treturn this;\n\t}\n\n\t/**\n\t * ### PostgreSQL documentation quote\n\t *\n\t * > An operator class with optional parameters can be specified for each column of an index.\n\t * The operator class identifies the operators to be used by the index for that column.\n\t * For example, a B-tree index on four-byte integers would use the int4_ops class;\n\t * this operator class includes comparison functions for four-byte integers.\n\t * In practice the default operator class for the column's data type is usually sufficient.\n\t * The main point of having operator classes is that for some data types, there could be more than one meaningful ordering.\n\t * For example, we might want to sort a complex-number data type either by absolute value or by real part.\n\t * We could do this by defining two operator classes for the data type and then selecting the proper class when creating an index.\n\t * More information about operator classes check:\n\t *\n\t * ### Useful links\n\t * https://www.postgresql.org/docs/current/sql-createindex.html\n\t *\n\t * https://www.postgresql.org/docs/current/indexes-opclass.html\n\t *\n\t * https://www.postgresql.org/docs/current/xindex.html\n\t *\n\t * ### Additional types\n\t * If you have the `pg_vector` extension installed in your database, you can use the\n\t * `vector_l2_ops`, `vector_ip_ops`, `vector_cosine_ops`, `vector_l1_ops`, `bit_hamming_ops`, `bit_jaccard_ops`, `halfvec_l2_ops`, `sparsevec_l2_ops` options, which are predefined types.\n\t *\n\t * **You can always specify any string you want in the operator class, in case Drizzle doesn't have it natively in its types**\n\t *\n\t * @param opClass\n\t * @returns\n\t */\n\top(opClass: PgIndexOpClass): Omit<this, 'op'> {\n\t\tthis.indexConfig.opClass = opClass;\n\t\treturn this;\n\t}\n}\n\nexport class IndexedColumn {\n\tstatic readonly [entityKind]: string = 'IndexedColumn';\n\tconstructor(\n\t\tname: string | undefined,\n\t\tkeyAsName: boolean,\n\t\ttype: string,\n\t\tindexConfig: IndexedExtraConfigType,\n\t) {\n\t\tthis.name = name;\n\t\tthis.keyAsName = keyAsName;\n\t\tthis.type = type;\n\t\tthis.indexConfig = indexConfig;\n\t}\n\n\tname: string | undefined;\n\tkeyAsName: boolean;\n\ttype: string;\n\tindexConfig: IndexedExtraConfigType;\n}\n\nexport type AnyPgColumn<TPartial extends Partial<ColumnBaseConfig<ColumnDataType, string>> = {}> = PgColumn<\n\tRequired<Update<ColumnBaseConfig<ColumnDataType, string>, TPartial>>\n>;\n\nexport type PgArrayColumnBuilderBaseConfig = ColumnBuilderBaseConfig<'array', 'PgArray'> & {\n\tsize: number | undefined;\n\tbaseBuilder: ColumnBuilderBaseConfig<ColumnDataType, string>;\n};\n\nexport class PgArrayBuilder<\n\tT extends PgArrayColumnBuilderBaseConfig,\n\tTBase extends ColumnBuilderBaseConfig<ColumnDataType, string> | PgArrayColumnBuilderBaseConfig,\n> extends PgColumnBuilder<\n\tT,\n\t{\n\t\tbaseBuilder: TBase extends PgArrayColumnBuilderBaseConfig ? PgArrayBuilder<\n\t\t\t\tTBase,\n\t\t\t\tTBase extends { baseBuilder: infer TBaseBuilder extends ColumnBuilderBaseConfig<any, any> } ? TBaseBuilder\n\t\t\t\t\t: never\n\t\t\t>\n\t\t\t: PgColumnBuilder<TBase, {}, Simplify<Omit<TBase, keyof ColumnBuilderBaseConfig<any, any>>>>;\n\t\tsize: T['size'];\n\t},\n\t{\n\t\tbaseBuilder: TBase extends PgArrayColumnBuilderBaseConfig ? PgArrayBuilder<\n\t\t\t\tTBase,\n\t\t\t\tTBase extends { baseBuilder: infer TBaseBuilder extends ColumnBuilderBaseConfig<any, any> } ? TBaseBuilder\n\t\t\t\t\t: never\n\t\t\t>\n\t\t\t: PgColumnBuilder<TBase, {}, Simplify<Omit<TBase, keyof ColumnBuilderBaseConfig<any, any>>>>;\n\t\tsize: T['size'];\n\t}\n> {\n\tstatic override readonly [entityKind] = 'PgArrayBuilder';\n\n\tconstructor(\n\t\tname: string,\n\t\tbaseBuilder: PgArrayBuilder<T, TBase>['config']['baseBuilder'],\n\t\tsize: T['size'],\n\t) {\n\t\tsuper(name, 'array', 'PgArray');\n\t\tthis.config.baseBuilder = baseBuilder;\n\t\tthis.config.size = size;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgArray<MakeColumnConfig<T, TTableName> & { size: T['size']; baseBuilder: T['baseBuilder'] }, TBase> {\n\t\tconst baseColumn = this.config.baseBuilder.build(table);\n\t\treturn new PgArray<MakeColumnConfig<T, TTableName> & { size: T['size']; baseBuilder: T['baseBuilder'] }, TBase>(\n\t\t\ttable as AnyPgTable<{ name: MakeColumnConfig<T, TTableName>['tableName'] }>,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t\tbaseColumn,\n\t\t);\n\t}\n}\n\nexport class PgArray<\n\tT extends ColumnBaseConfig<'array', 'PgArray'> & {\n\t\tsize: number | undefined;\n\t\tbaseBuilder: ColumnBuilderBaseConfig<ColumnDataType, string>;\n\t},\n\tTBase extends ColumnBuilderBaseConfig<ColumnDataType, string>,\n> extends PgColumn<T, {}, { size: T['size']; baseBuilder: T['baseBuilder'] }> {\n\treadonly size: T['size'];\n\n\tstatic override readonly [entityKind]: string = 'PgArray';\n\n\tconstructor(\n\t\ttable: AnyPgTable<{ name: T['tableName'] }>,\n\t\tconfig: PgArrayBuilder<T, TBase>['config'],\n\t\treadonly baseColumn: PgColumn,\n\t\treadonly range?: [number | undefined, number | undefined],\n\t) {\n\t\tsuper(table, config);\n\t\tthis.size = config.size;\n\t}\n\n\tgetSQLType(): string {\n\t\treturn `${this.baseColumn.getSQLType()}[${typeof this.size === 'number' ? this.size : ''}]`;\n\t}\n\n\toverride mapFromDriverValue(value: unknown[] | string): T['data'] {\n\t\tif (typeof value === 'string') {\n\t\t\t// Thank you node-postgres for not parsing enum arrays\n\t\t\tvalue = parsePgArray(value);\n\t\t}\n\t\treturn value.map((v) => this.baseColumn.mapFromDriverValue(v));\n\t}\n\n\toverride mapToDriverValue(value: unknown[], isNestedArray = false): unknown[] | string {\n\t\tconst a = value.map((v) =>\n\t\t\tv === null\n\t\t\t\t? null\n\t\t\t\t: is(this.baseColumn, PgArray)\n\t\t\t\t? this.baseColumn.mapToDriverValue(v as unknown[], true)\n\t\t\t\t: this.baseColumn.mapToDriverValue(v)\n\t\t);\n\t\tif (isNestedArray) return a;\n\t\treturn makePgArray(a);\n\t}\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport type { Writable } from '~/utils.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgEnumColumnBuilderInitial<TName extends string, TValues extends [string, ...string[]]> =\n\tPgEnumColumnBuilder<{\n\t\tname: TName;\n\t\tdataType: 'string';\n\t\tcolumnType: 'PgEnumColumn';\n\t\tdata: TValues[number];\n\t\tenumValues: TValues;\n\t\tdriverParam: string;\n\t}>;\n\nconst isPgEnumSym = Symbol.for('drizzle:isPgEnum');\nexport interface PgEnum<TValues extends [string, ...string[]]> {\n\t(): PgEnumColumnBuilderInitial<'', TValues>;\n\t<TName extends string>(name: TName): PgEnumColumnBuilderInitial<TName, TValues>;\n\t<TName extends string>(name?: TName): PgEnumColumnBuilderInitial<TName, TValues>;\n\n\treadonly enumName: string;\n\treadonly enumValues: TValues;\n\treadonly schema: string | undefined;\n\t/** @internal */\n\t[isPgEnumSym]: true;\n}\n\nexport function isPgEnum(obj: unknown): obj is PgEnum<[string, ...string[]]> {\n\treturn !!obj && typeof obj === 'function' && isPgEnumSym in obj && obj[isPgEnumSym] === true;\n}\n\nexport class PgEnumColumnBuilder<\n\tT extends ColumnBuilderBaseConfig<'string', 'PgEnumColumn'> & { enumValues: [string, ...string[]] },\n> extends PgColumnBuilder<T, { enum: PgEnum<T['enumValues']> }> {\n\tstatic override readonly [entityKind]: string = 'PgEnumColumnBuilder';\n\n\tconstructor(name: T['name'], enumInstance: PgEnum<T['enumValues']>) {\n\t\tsuper(name, 'string', 'PgEnumColumn');\n\t\tthis.config.enum = enumInstance;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgEnumColumn<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgEnumColumn<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgEnumColumn<T extends ColumnBaseConfig<'string', 'PgEnumColumn'> & { enumValues: [string, ...string[]] }>\n\textends PgColumn<T, { enum: PgEnum<T['enumValues']> }>\n{\n\tstatic override readonly [entityKind]: string = 'PgEnumColumn';\n\n\treadonly enum = this.config.enum;\n\toverride readonly enumValues = this.config.enum.enumValues;\n\n\tconstructor(\n\t\ttable: AnyPgTable<{ name: T['tableName'] }>,\n\t\tconfig: PgEnumColumnBuilder<T>['config'],\n\t) {\n\t\tsuper(table, config);\n\t\tthis.enum = config.enum;\n\t}\n\n\tgetSQLType(): string {\n\t\treturn this.enum.enumName;\n\t}\n}\n\n// Gratitude to zod for the enum function types\nexport function pgEnum<U extends string, T extends Readonly<[U, ...U[]]>>(\n\tenumName: string,\n\tvalues: T | Writable<T>,\n): PgEnum<Writable<T>> {\n\treturn pgEnumWithSchema(enumName, values, undefined);\n}\n\n/** @internal */\nexport function pgEnumWithSchema<U extends string, T extends Readonly<[U, ...U[]]>>(\n\tenumName: string,\n\tvalues: T | Writable<T>,\n\tschema?: string,\n): PgEnum<Writable<T>> {\n\tconst enumInstance: PgEnum<Writable<T>> = Object.assign(\n\t\t<TName extends string>(name?: TName): PgEnumColumnBuilderInitial<TName, Writable<T>> =>\n\t\t\tnew PgEnumColumnBuilder(name ?? '' as TName, enumInstance),\n\t\t{\n\t\t\tenumName,\n\t\t\tenumValues: values,\n\t\t\tschema,\n\t\t\t[isPgEnumSym]: true,\n\t\t} as const,\n\t);\n\n\treturn enumInstance;\n}\n","import { entityKind } from './entity.ts';\nimport type { SQL, SQLWrapper } from './sql/sql.ts';\n\nexport interface Subquery<\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTAlias extends string = string,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTSelectedFields extends Record<string, unknown> = Record<string, unknown>,\n> extends SQLWrapper {\n\t// SQLWrapper runtime implementation is defined in 'sql/sql.ts'\n}\nexport class Subquery<\n\tTAlias extends string = string,\n\tTSelectedFields extends Record<string, unknown> = Record<string, unknown>,\n> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Subquery';\n\n\tdeclare _: {\n\t\tbrand: 'Subquery';\n\t\tsql: SQL;\n\t\tselectedFields: TSelectedFields;\n\t\talias: TAlias;\n\t\tisWith: boolean;\n\t};\n\n\tconstructor(sql: SQL, selection: Record<string, unknown>, alias: string, isWith = false) {\n\t\tthis._ = {\n\t\t\tbrand: 'Subquery',\n\t\t\tsql,\n\t\t\tselectedFields: selection as TSelectedFields,\n\t\t\talias: alias as TAlias,\n\t\t\tisWith,\n\t\t};\n\t}\n\n\t// getSQL(): SQL<unknown> {\n\t// \treturn new SQL([this]);\n\t// }\n}\n\nexport class WithSubquery<\n\tTAlias extends string = string,\n\tTSelection extends Record<string, unknown> = Record<string, unknown>,\n> extends Subquery<TAlias, TSelection> {\n\tstatic override readonly [entityKind]: string = 'WithSubquery';\n}\n\nexport type WithSubqueryWithoutSelection<TAlias extends string> = WithSubquery<TAlias, {}>;\n","// package.json\nvar version = \"0.40.0\";\n\n// src/version.ts\nvar compatibilityVersion = 10;\nexport {\n  compatibilityVersion,\n  version as npmVersion\n};\n","import type { Span, Tracer } from '@opentelemetry/api';\nimport { iife } from '~/tracing-utils.ts';\nimport { npmVersion } from '~/version.ts';\n\nlet otel: typeof import('@opentelemetry/api') | undefined;\nlet rawTracer: Tracer | undefined;\n// try {\n// \totel = await import('@opentelemetry/api');\n// } catch (err: any) {\n// \tif (err.code !== 'MODULE_NOT_FOUND' && err.code !== 'ERR_MODULE_NOT_FOUND') {\n// \t\tthrow err;\n// \t}\n// }\n\ntype SpanName =\n\t| 'drizzle.operation'\n\t| 'drizzle.prepareQuery'\n\t| 'drizzle.buildSQL'\n\t| 'drizzle.execute'\n\t| 'drizzle.driver.execute'\n\t| 'drizzle.mapResponse';\n\n/** @internal */\nexport const tracer = {\n\tstartActiveSpan<F extends (span?: Span) => unknown>(name: SpanName, fn: F): ReturnType<F> {\n\t\tif (!otel) {\n\t\t\treturn fn() as ReturnType<F>;\n\t\t}\n\n\t\tif (!rawTracer) {\n\t\t\trawTracer = otel.trace.getTracer('drizzle-orm', npmVersion);\n\t\t}\n\n\t\treturn iife(\n\t\t\t(otel, rawTracer) =>\n\t\t\t\trawTracer.startActiveSpan(\n\t\t\t\t\tname,\n\t\t\t\t\t((span: Span) => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn fn(span);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tspan.setStatus({\n\t\t\t\t\t\t\t\tcode: otel.SpanStatusCode.ERROR,\n\t\t\t\t\t\t\t\tmessage: e instanceof Error ? e.message : 'Unknown error', // eslint-disable-line no-instanceof/no-instanceof\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tspan.end();\n\t\t\t\t\t\t}\n\t\t\t\t\t}) as F,\n\t\t\t\t),\n\t\t\totel,\n\t\t\trawTracer,\n\t\t);\n\t},\n};\n","export const ViewBaseConfig = Symbol.for('drizzle:ViewBaseConfig');\n","import type { Column, GetColumnData } from './column.ts';\nimport { entityKind } from './entity.ts';\nimport type { OptionalKeyOnly, RequiredKeyOnly } from './operations.ts';\nimport type { SQLWrapper } from './sql/sql.ts';\nimport { TableName } from './table.utils.ts';\nimport type { Simplify, Update } from './utils.ts';\n\nexport interface TableConfig<TColumn extends Column = Column<any>> {\n\tname: string;\n\tschema: string | undefined;\n\tcolumns: Record<string, TColumn>;\n\tdialect: string;\n}\n\nexport type UpdateTableConfig<T extends TableConfig, TUpdate extends Partial<TableConfig>> = Required<\n\tUpdate<T, TUpdate>\n>;\n\n/** @internal */\nexport const Schema = Symbol.for('drizzle:Schema');\n\n/** @internal */\nexport const Columns = Symbol.for('drizzle:Columns');\n\n/** @internal */\nexport const ExtraConfigColumns = Symbol.for('drizzle:ExtraConfigColumns');\n\n/** @internal */\nexport const OriginalName = Symbol.for('drizzle:OriginalName');\n\n/** @internal */\nexport const BaseName = Symbol.for('drizzle:BaseName');\n\n/** @internal */\nexport const IsAlias = Symbol.for('drizzle:IsAlias');\n\n/** @internal */\nexport const ExtraConfigBuilder = Symbol.for('drizzle:ExtraConfigBuilder');\n\nconst IsDrizzleTable = Symbol.for('drizzle:IsDrizzleTable');\n\nexport interface Table<\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tT extends TableConfig = TableConfig,\n> extends SQLWrapper {\n\t// SQLWrapper runtime implementation is defined in 'sql/sql.ts'\n}\n\nexport class Table<T extends TableConfig = TableConfig> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Table';\n\n\tdeclare readonly _: {\n\t\treadonly brand: 'Table';\n\t\treadonly config: T;\n\t\treadonly name: T['name'];\n\t\treadonly schema: T['schema'];\n\t\treadonly columns: T['columns'];\n\t\treadonly inferSelect: InferSelectModel<Table<T>>;\n\t\treadonly inferInsert: InferInsertModel<Table<T>>;\n\t};\n\n\tdeclare readonly $inferSelect: InferSelectModel<Table<T>>;\n\tdeclare readonly $inferInsert: InferInsertModel<Table<T>>;\n\n\t/** @internal */\n\tstatic readonly Symbol = {\n\t\tName: TableName as typeof TableName,\n\t\tSchema: Schema as typeof Schema,\n\t\tOriginalName: OriginalName as typeof OriginalName,\n\t\tColumns: Columns as typeof Columns,\n\t\tExtraConfigColumns: ExtraConfigColumns as typeof ExtraConfigColumns,\n\t\tBaseName: BaseName as typeof BaseName,\n\t\tIsAlias: IsAlias as typeof IsAlias,\n\t\tExtraConfigBuilder: ExtraConfigBuilder as typeof ExtraConfigBuilder,\n\t};\n\n\t/**\n\t * @internal\n\t * Can be changed if the table is aliased.\n\t */\n\t[TableName]: string;\n\n\t/**\n\t * @internal\n\t * Used to store the original name of the table, before any aliasing.\n\t */\n\t[OriginalName]: string;\n\n\t/** @internal */\n\t[Schema]: string | undefined;\n\n\t/** @internal */\n\t[Columns]!: T['columns'];\n\n\t/** @internal */\n\t[ExtraConfigColumns]!: Record<string, unknown>;\n\n\t/**\n\t *  @internal\n\t * Used to store the table name before the transformation via the `tableCreator` functions.\n\t */\n\t[BaseName]: string;\n\n\t/** @internal */\n\t[IsAlias] = false;\n\n\t/** @internal */\n\t[IsDrizzleTable] = true;\n\n\t/** @internal */\n\t[ExtraConfigBuilder]: ((self: any) => Record<string, unknown> | unknown[]) | undefined = undefined;\n\n\tconstructor(name: string, schema: string | undefined, baseName: string) {\n\t\tthis[TableName] = this[OriginalName] = name;\n\t\tthis[Schema] = schema;\n\t\tthis[BaseName] = baseName;\n\t}\n}\n\nexport function isTable(table: unknown): table is Table {\n\treturn typeof table === 'object' && table !== null && IsDrizzleTable in table;\n}\n\n/**\n * Any table with a specified boundary.\n *\n * @example\n\t```ts\n\t// Any table with a specific name\n\ttype AnyUsersTable = AnyTable<{ name: 'users' }>;\n\t```\n *\n * To describe any table with any config, simply use `Table` without any type arguments, like this:\n *\n\t```ts\n\tfunction needsTable(table: Table) {\n\t\t...\n\t}\n\t```\n */\nexport type AnyTable<TPartial extends Partial<TableConfig>> = Table<UpdateTableConfig<TableConfig, TPartial>>;\n\nexport function getTableName<T extends Table>(table: T): T['_']['name'] {\n\treturn table[TableName];\n}\n\nexport function getTableUniqueName<T extends Table>(table: T): `${T['_']['schema']}.${T['_']['name']}` {\n\treturn `${table[Schema] ?? 'public'}.${table[TableName]}`;\n}\n\nexport type MapColumnName<TName extends string, TColumn extends Column, TDBColumNames extends boolean> =\n\tTDBColumNames extends true ? TColumn['_']['name']\n\t\t: TName;\n\nexport type InferModelFromColumns<\n\tTColumns extends Record<string, Column>,\n\tTInferMode extends 'select' | 'insert' = 'select',\n\tTConfig extends { dbColumnNames: boolean; override?: boolean } = { dbColumnNames: false; override: false },\n> = Simplify<\n\tTInferMode extends 'insert' ?\n\t\t\t& {\n\t\t\t\t[\n\t\t\t\t\tKey in keyof TColumns & string as RequiredKeyOnly<\n\t\t\t\t\t\tMapColumnName<Key, TColumns[Key], TConfig['dbColumnNames']>,\n\t\t\t\t\t\tTColumns[Key]\n\t\t\t\t\t>\n\t\t\t\t]: GetColumnData<TColumns[Key], 'query'>;\n\t\t\t}\n\t\t\t& {\n\t\t\t\t[\n\t\t\t\t\tKey in keyof TColumns & string as OptionalKeyOnly<\n\t\t\t\t\t\tMapColumnName<Key, TColumns[Key], TConfig['dbColumnNames']>,\n\t\t\t\t\t\tTColumns[Key],\n\t\t\t\t\t\tTConfig['override']\n\t\t\t\t\t>\n\t\t\t\t]?: GetColumnData<TColumns[Key], 'query'> | undefined;\n\t\t\t}\n\t\t: {\n\t\t\t[\n\t\t\t\tKey in keyof TColumns & string as MapColumnName<\n\t\t\t\t\tKey,\n\t\t\t\t\tTColumns[Key],\n\t\t\t\t\tTConfig['dbColumnNames']\n\t\t\t\t>\n\t\t\t]: GetColumnData<TColumns[Key], 'query'>;\n\t\t}\n>;\n\n/** @deprecated Use one of the alternatives: {@link InferSelectModel} / {@link InferInsertModel}, or `table.$inferSelect` / `table.$inferInsert`\n */\nexport type InferModel<\n\tTTable extends Table,\n\tTInferMode extends 'select' | 'insert' = 'select',\n\tTConfig extends { dbColumnNames: boolean } = { dbColumnNames: false },\n> = InferModelFromColumns<TTable['_']['columns'], TInferMode, TConfig>;\n\nexport type InferSelectModel<\n\tTTable extends Table,\n\tTConfig extends { dbColumnNames: boolean } = { dbColumnNames: false },\n> = InferModelFromColumns<TTable['_']['columns'], 'select', TConfig>;\n\nexport type InferInsertModel<\n\tTTable extends Table,\n\tTConfig extends { dbColumnNames: boolean; override?: boolean } = { dbColumnNames: false; override: false },\n> = InferModelFromColumns<TTable['_']['columns'], 'insert', TConfig>;\n","import type { CasingCache } from '~/casing.ts';\nimport { entityKind, is } from '~/entity.ts';\nimport { isPgEnum } from '~/pg-core/columns/enum.ts';\nimport type { SelectResult } from '~/query-builders/select.types.ts';\nimport { Subquery } from '~/subquery.ts';\nimport { tracer } from '~/tracing.ts';\nimport type { Assume, Equal } from '~/utils.ts';\nimport { ViewBaseConfig } from '~/view-common.ts';\nimport type { AnyColumn } from '../column.ts';\nimport { Column } from '../column.ts';\nimport { IsAlias, Table } from '../table.ts';\n\n/**\n * This class is used to indicate a primitive param value that is used in `sql` tag.\n * It is only used on type level and is never instantiated at runtime.\n * If you see a value of this type in the code, its runtime value is actually the primitive param value.\n */\nexport class FakePrimitiveParam {\n\tstatic readonly [entityKind]: string = 'FakePrimitiveParam';\n}\n\nexport type Chunk =\n\t| string\n\t| Table\n\t| View\n\t| AnyColumn\n\t| Name\n\t| Param\n\t| Placeholder\n\t| SQL;\n\nexport interface BuildQueryConfig {\n\tcasing: CasingCache;\n\tescapeName(name: string): string;\n\tescapeParam(num: number, value: unknown): string;\n\tescapeString(str: string): string;\n\tprepareTyping?: (encoder: DriverValueEncoder<unknown, unknown>) => QueryTypingsValue;\n\tparamStartIndex?: { value: number };\n\tinlineParams?: boolean;\n\tinvokeSource?: 'indexes' | undefined;\n}\n\nexport type QueryTypingsValue = 'json' | 'decimal' | 'time' | 'timestamp' | 'uuid' | 'date' | 'none';\n\nexport interface Query {\n\tsql: string;\n\tparams: unknown[];\n}\n\nexport interface QueryWithTypings extends Query {\n\ttypings?: QueryTypingsValue[];\n}\n\n/**\n * Any value that implements the `getSQL` method. The implementations include:\n * - `Table`\n * - `Column`\n * - `View`\n * - `Subquery`\n * - `SQL`\n * - `SQL.Aliased`\n * - `Placeholder`\n * - `Param`\n */\nexport interface SQLWrapper {\n\tgetSQL(): SQL;\n\tshouldOmitSQLParens?(): boolean;\n}\n\nexport function isSQLWrapper(value: unknown): value is SQLWrapper {\n\treturn value !== null && value !== undefined && typeof (value as any).getSQL === 'function';\n}\n\nfunction mergeQueries(queries: QueryWithTypings[]): QueryWithTypings {\n\tconst result: QueryWithTypings = { sql: '', params: [] };\n\tfor (const query of queries) {\n\t\tresult.sql += query.sql;\n\t\tresult.params.push(...query.params);\n\t\tif (query.typings?.length) {\n\t\t\tif (!result.typings) {\n\t\t\t\tresult.typings = [];\n\t\t\t}\n\t\t\tresult.typings.push(...query.typings);\n\t\t}\n\t}\n\treturn result;\n}\n\nexport class StringChunk implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'StringChunk';\n\n\treadonly value: string[];\n\n\tconstructor(value: string | string[]) {\n\t\tthis.value = Array.isArray(value) ? value : [value];\n\t}\n\n\tgetSQL(): SQL<unknown> {\n\t\treturn new SQL([this]);\n\t}\n}\n\nexport class SQL<T = unknown> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'SQL';\n\n\tdeclare _: {\n\t\tbrand: 'SQL';\n\t\ttype: T;\n\t};\n\n\t/** @internal */\n\tdecoder: DriverValueDecoder<T, any> = noopDecoder;\n\tprivate shouldInlineParams = false;\n\n\tconstructor(readonly queryChunks: SQLChunk[]) {}\n\n\tappend(query: SQL): this {\n\t\tthis.queryChunks.push(...query.queryChunks);\n\t\treturn this;\n\t}\n\n\ttoQuery(config: BuildQueryConfig): QueryWithTypings {\n\t\treturn tracer.startActiveSpan('drizzle.buildSQL', (span) => {\n\t\t\tconst query = this.buildQueryFromSourceParams(this.queryChunks, config);\n\t\t\tspan?.setAttributes({\n\t\t\t\t'drizzle.query.text': query.sql,\n\t\t\t\t'drizzle.query.params': JSON.stringify(query.params),\n\t\t\t});\n\t\t\treturn query;\n\t\t});\n\t}\n\n\tbuildQueryFromSourceParams(chunks: SQLChunk[], _config: BuildQueryConfig): Query {\n\t\tconst config = Object.assign({}, _config, {\n\t\t\tinlineParams: _config.inlineParams || this.shouldInlineParams,\n\t\t\tparamStartIndex: _config.paramStartIndex || { value: 0 },\n\t\t});\n\n\t\tconst {\n\t\t\tcasing,\n\t\t\tescapeName,\n\t\t\tescapeParam,\n\t\t\tprepareTyping,\n\t\t\tinlineParams,\n\t\t\tparamStartIndex,\n\t\t} = config;\n\n\t\treturn mergeQueries(chunks.map((chunk): QueryWithTypings => {\n\t\t\tif (is(chunk, StringChunk)) {\n\t\t\t\treturn { sql: chunk.value.join(''), params: [] };\n\t\t\t}\n\n\t\t\tif (is(chunk, Name)) {\n\t\t\t\treturn { sql: escapeName(chunk.value), params: [] };\n\t\t\t}\n\n\t\t\tif (chunk === undefined) {\n\t\t\t\treturn { sql: '', params: [] };\n\t\t\t}\n\n\t\t\tif (Array.isArray(chunk)) {\n\t\t\t\tconst result: SQLChunk[] = [new StringChunk('(')];\n\t\t\t\tfor (const [i, p] of chunk.entries()) {\n\t\t\t\t\tresult.push(p);\n\t\t\t\t\tif (i < chunk.length - 1) {\n\t\t\t\t\t\tresult.push(new StringChunk(', '));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult.push(new StringChunk(')'));\n\t\t\t\treturn this.buildQueryFromSourceParams(result, config);\n\t\t\t}\n\n\t\t\tif (is(chunk, SQL)) {\n\t\t\t\treturn this.buildQueryFromSourceParams(chunk.queryChunks, {\n\t\t\t\t\t...config,\n\t\t\t\t\tinlineParams: inlineParams || chunk.shouldInlineParams,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (is(chunk, Table)) {\n\t\t\t\tconst schemaName = chunk[Table.Symbol.Schema];\n\t\t\t\tconst tableName = chunk[Table.Symbol.Name];\n\t\t\t\treturn {\n\t\t\t\t\tsql: schemaName === undefined || chunk[IsAlias]\n\t\t\t\t\t\t? escapeName(tableName)\n\t\t\t\t\t\t: escapeName(schemaName) + '.' + escapeName(tableName),\n\t\t\t\t\tparams: [],\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (is(chunk, Column)) {\n\t\t\t\tconst columnName = casing.getColumnCasing(chunk);\n\t\t\t\tif (_config.invokeSource === 'indexes') {\n\t\t\t\t\treturn { sql: escapeName(columnName), params: [] };\n\t\t\t\t}\n\n\t\t\t\tconst schemaName = chunk.table[Table.Symbol.Schema];\n\t\t\t\treturn {\n\t\t\t\t\tsql: chunk.table[IsAlias] || schemaName === undefined\n\t\t\t\t\t\t? escapeName(chunk.table[Table.Symbol.Name]) + '.' + escapeName(columnName)\n\t\t\t\t\t\t: escapeName(schemaName) + '.' + escapeName(chunk.table[Table.Symbol.Name]) + '.'\n\t\t\t\t\t\t\t+ escapeName(columnName),\n\t\t\t\t\tparams: [],\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (is(chunk, View)) {\n\t\t\t\tconst schemaName = chunk[ViewBaseConfig].schema;\n\t\t\t\tconst viewName = chunk[ViewBaseConfig].name;\n\t\t\t\treturn {\n\t\t\t\t\tsql: schemaName === undefined || chunk[ViewBaseConfig].isAlias\n\t\t\t\t\t\t? escapeName(viewName)\n\t\t\t\t\t\t: escapeName(schemaName) + '.' + escapeName(viewName),\n\t\t\t\t\tparams: [],\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (is(chunk, Param)) {\n\t\t\t\tif (is(chunk.value, Placeholder)) {\n\t\t\t\t\treturn { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ['none'] };\n\t\t\t\t}\n\n\t\t\t\tconst mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);\n\n\t\t\t\tif (is(mappedValue, SQL)) {\n\t\t\t\t\treturn this.buildQueryFromSourceParams([mappedValue], config);\n\t\t\t\t}\n\n\t\t\t\tif (inlineParams) {\n\t\t\t\t\treturn { sql: this.mapInlineParam(mappedValue, config), params: [] };\n\t\t\t\t}\n\n\t\t\t\tlet typings: QueryTypingsValue[] = ['none'];\n\t\t\t\tif (prepareTyping) {\n\t\t\t\t\ttypings = [prepareTyping(chunk.encoder)];\n\t\t\t\t}\n\n\t\t\t\treturn { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };\n\t\t\t}\n\n\t\t\tif (is(chunk, Placeholder)) {\n\t\t\t\treturn { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ['none'] };\n\t\t\t}\n\n\t\t\tif (is(chunk, SQL.Aliased) && chunk.fieldAlias !== undefined) {\n\t\t\t\treturn { sql: escapeName(chunk.fieldAlias), params: [] };\n\t\t\t}\n\n\t\t\tif (is(chunk, Subquery)) {\n\t\t\t\tif (chunk._.isWith) {\n\t\t\t\t\treturn { sql: escapeName(chunk._.alias), params: [] };\n\t\t\t\t}\n\t\t\t\treturn this.buildQueryFromSourceParams([\n\t\t\t\t\tnew StringChunk('('),\n\t\t\t\t\tchunk._.sql,\n\t\t\t\t\tnew StringChunk(') '),\n\t\t\t\t\tnew Name(chunk._.alias),\n\t\t\t\t], config);\n\t\t\t}\n\n\t\t\tif (isPgEnum(chunk)) {\n\t\t\t\tif (chunk.schema) {\n\t\t\t\t\treturn { sql: escapeName(chunk.schema) + '.' + escapeName(chunk.enumName), params: [] };\n\t\t\t\t}\n\t\t\t\treturn { sql: escapeName(chunk.enumName), params: [] };\n\t\t\t}\n\n\t\t\tif (isSQLWrapper(chunk)) {\n\t\t\t\tif (chunk.shouldOmitSQLParens?.()) {\n\t\t\t\t\treturn this.buildQueryFromSourceParams([chunk.getSQL()], config);\n\t\t\t\t}\n\t\t\t\treturn this.buildQueryFromSourceParams([\n\t\t\t\t\tnew StringChunk('('),\n\t\t\t\t\tchunk.getSQL(),\n\t\t\t\t\tnew StringChunk(')'),\n\t\t\t\t], config);\n\t\t\t}\n\n\t\t\tif (inlineParams) {\n\t\t\t\treturn { sql: this.mapInlineParam(chunk, config), params: [] };\n\t\t\t}\n\n\t\t\treturn { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ['none'] };\n\t\t}));\n\t}\n\n\tprivate mapInlineParam(\n\t\tchunk: unknown,\n\t\t{ escapeString }: BuildQueryConfig,\n\t): string {\n\t\tif (chunk === null) {\n\t\t\treturn 'null';\n\t\t}\n\t\tif (typeof chunk === 'number' || typeof chunk === 'boolean') {\n\t\t\treturn chunk.toString();\n\t\t}\n\t\tif (typeof chunk === 'string') {\n\t\t\treturn escapeString(chunk);\n\t\t}\n\t\tif (typeof chunk === 'object') {\n\t\t\tconst mappedValueAsString = chunk.toString();\n\t\t\tif (mappedValueAsString === '[object Object]') {\n\t\t\t\treturn escapeString(JSON.stringify(chunk));\n\t\t\t}\n\t\t\treturn escapeString(mappedValueAsString);\n\t\t}\n\t\tthrow new Error('Unexpected param value: ' + chunk);\n\t}\n\n\tgetSQL(): SQL {\n\t\treturn this;\n\t}\n\n\tas(alias: string): SQL.Aliased<T>;\n\t/**\n\t * @deprecated\n\t * Use ``sql<DataType>`query`.as(alias)`` instead.\n\t */\n\tas<TData>(): SQL<TData>;\n\t/**\n\t * @deprecated\n\t * Use ``sql<DataType>`query`.as(alias)`` instead.\n\t */\n\tas<TData>(alias: string): SQL.Aliased<TData>;\n\tas(alias?: string): SQL<T> | SQL.Aliased<T> {\n\t\t// TODO: remove with deprecated overloads\n\t\tif (alias === undefined) {\n\t\t\treturn this;\n\t\t}\n\n\t\treturn new SQL.Aliased(this, alias);\n\t}\n\n\tmapWith<\n\t\tTDecoder extends\n\t\t\t| DriverValueDecoder<any, any>\n\t\t\t| DriverValueDecoder<any, any>['mapFromDriverValue'],\n\t>(decoder: TDecoder): SQL<GetDecoderResult<TDecoder>> {\n\t\tthis.decoder = typeof decoder === 'function' ? { mapFromDriverValue: decoder } : decoder;\n\t\treturn this as SQL<GetDecoderResult<TDecoder>>;\n\t}\n\n\tinlineParams(): this {\n\t\tthis.shouldInlineParams = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * This method is used to conditionally include a part of the query.\n\t *\n\t * @param condition - Condition to check\n\t * @returns itself if the condition is `true`, otherwise `undefined`\n\t */\n\tif(condition: any | undefined): this | undefined {\n\t\treturn condition ? this : undefined;\n\t}\n}\n\nexport type GetDecoderResult<T> = T extends Column ? T['_']['data'] : T extends\n\t| DriverValueDecoder<infer TData, any>\n\t| DriverValueDecoder<infer TData, any>['mapFromDriverValue'] ? TData\n: never;\n\n/**\n * Any DB name (table, column, index etc.)\n */\nexport class Name implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Name';\n\n\tprotected brand!: 'Name';\n\n\tconstructor(readonly value: string) {}\n\n\tgetSQL(): SQL<unknown> {\n\t\treturn new SQL([this]);\n\t}\n}\n\n/**\n * Any DB name (table, column, index etc.)\n * @deprecated Use `sql.identifier` instead.\n */\nexport function name(value: string): Name {\n\treturn new Name(value);\n}\n\nexport interface DriverValueDecoder<TData, TDriverParam> {\n\tmapFromDriverValue(value: TDriverParam): TData;\n}\n\nexport interface DriverValueEncoder<TData, TDriverParam> {\n\tmapToDriverValue(value: TData): TDriverParam | SQL;\n}\n\nexport function isDriverValueEncoder(value: unknown): value is DriverValueEncoder<any, any> {\n\treturn typeof value === 'object' && value !== null && 'mapToDriverValue' in value\n\t\t&& typeof (value as any).mapToDriverValue === 'function';\n}\n\nexport const noopDecoder: DriverValueDecoder<any, any> = {\n\tmapFromDriverValue: (value) => value,\n};\n\nexport const noopEncoder: DriverValueEncoder<any, any> = {\n\tmapToDriverValue: (value) => value,\n};\n\nexport interface DriverValueMapper<TData, TDriverParam>\n\textends DriverValueDecoder<TData, TDriverParam>, DriverValueEncoder<TData, TDriverParam>\n{}\n\nexport const noopMapper: DriverValueMapper<any, any> = {\n\t...noopDecoder,\n\t...noopEncoder,\n};\n\n/** Parameter value that is optionally bound to an encoder (for example, a column). */\nexport class Param<TDataType = unknown, TDriverParamType = TDataType> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Param';\n\n\tprotected brand!: 'BoundParamValue';\n\n\t/**\n\t * @param value - Parameter value\n\t * @param encoder - Encoder to convert the value to a driver parameter\n\t */\n\tconstructor(\n\t\treadonly value: TDataType,\n\t\treadonly encoder: DriverValueEncoder<TDataType, TDriverParamType> = noopEncoder,\n\t) {}\n\n\tgetSQL(): SQL<unknown> {\n\t\treturn new SQL([this]);\n\t}\n}\n\n/** @deprecated Use `sql.param` instead. */\nexport function param<TData, TDriver>(\n\tvalue: TData,\n\tencoder?: DriverValueEncoder<TData, TDriver>,\n): Param<TData, TDriver> {\n\treturn new Param(value, encoder);\n}\n\n/**\n * Anything that can be passed to the `` sql`...` `` tagged function.\n */\nexport type SQLChunk =\n\t| StringChunk\n\t| SQLChunk[]\n\t| SQLWrapper\n\t| SQL\n\t| Table\n\t| View\n\t| Subquery\n\t| AnyColumn\n\t| Param\n\t| Name\n\t| undefined\n\t| FakePrimitiveParam\n\t| Placeholder;\n\nexport function sql<T>(strings: TemplateStringsArray, ...params: any[]): SQL<T>;\n/*\n\tThe type of `params` is specified as `SQLChunk[]`, but that's slightly incorrect -\n\tin runtime, users won't pass `FakePrimitiveParam` instances as `params` - they will pass primitive values\n\twhich will be wrapped in `Param`. That's why the overload specifies `params` as `any[]` and not as `SQLSourceParam[]`.\n\tThis type is used to make our lives easier and the type checker happy.\n*/\nexport function sql(strings: TemplateStringsArray, ...params: SQLChunk[]): SQL {\n\tconst queryChunks: SQLChunk[] = [];\n\tif (params.length > 0 || (strings.length > 0 && strings[0] !== '')) {\n\t\tqueryChunks.push(new StringChunk(strings[0]!));\n\t}\n\tfor (const [paramIndex, param] of params.entries()) {\n\t\tqueryChunks.push(param, new StringChunk(strings[paramIndex + 1]!));\n\t}\n\n\treturn new SQL(queryChunks);\n}\n\nexport namespace sql {\n\texport function empty(): SQL {\n\t\treturn new SQL([]);\n\t}\n\n\t/** @deprecated - use `sql.join()` */\n\texport function fromList(list: SQLChunk[]): SQL {\n\t\treturn new SQL(list);\n\t}\n\n\t/**\n\t * Convenience function to create an SQL query from a raw string.\n\t * @param str The raw SQL query string.\n\t */\n\texport function raw(str: string): SQL {\n\t\treturn new SQL([new StringChunk(str)]);\n\t}\n\n\t/**\n\t * Join a list of SQL chunks with a separator.\n\t * @example\n\t * ```ts\n\t * const query = sql.join([sql`a`, sql`b`, sql`c`]);\n\t * // sql`abc`\n\t * ```\n\t * @example\n\t * ```ts\n\t * const query = sql.join([sql`a`, sql`b`, sql`c`], sql`, `);\n\t * // sql`a, b, c`\n\t * ```\n\t */\n\texport function join(chunks: SQLChunk[], separator?: SQLChunk): SQL {\n\t\tconst result: SQLChunk[] = [];\n\t\tfor (const [i, chunk] of chunks.entries()) {\n\t\t\tif (i > 0 && separator !== undefined) {\n\t\t\t\tresult.push(separator);\n\t\t\t}\n\t\t\tresult.push(chunk);\n\t\t}\n\t\treturn new SQL(result);\n\t}\n\n\t/**\n\t * Create a SQL chunk that represents a DB identifier (table, column, index etc.).\n\t * When used in a query, the identifier will be escaped based on the DB engine.\n\t * For example, in PostgreSQL, identifiers are escaped with double quotes.\n\t *\n\t * **WARNING: This function does not offer any protection against SQL injections, so you must validate any user input beforehand.**\n\t *\n\t * @example ```ts\n\t * const query = sql`SELECT * FROM ${sql.identifier('my-table')}`;\n\t * // 'SELECT * FROM \"my-table\"'\n\t * ```\n\t */\n\texport function identifier(value: string): Name {\n\t\treturn new Name(value);\n\t}\n\n\texport function placeholder<TName extends string>(name: TName): Placeholder<TName> {\n\t\treturn new Placeholder(name);\n\t}\n\n\texport function param<TData, TDriver>(\n\t\tvalue: TData,\n\t\tencoder?: DriverValueEncoder<TData, TDriver>,\n\t): Param<TData, TDriver> {\n\t\treturn new Param(value, encoder);\n\t}\n}\n\nexport namespace SQL {\n\texport class Aliased<T = unknown> implements SQLWrapper {\n\t\tstatic readonly [entityKind]: string = 'SQL.Aliased';\n\n\t\tdeclare _: {\n\t\t\tbrand: 'SQL.Aliased';\n\t\t\ttype: T;\n\t\t};\n\n\t\t/** @internal */\n\t\tisSelectionField = false;\n\n\t\tconstructor(\n\t\t\treadonly sql: SQL,\n\t\t\treadonly fieldAlias: string,\n\t\t) {}\n\n\t\tgetSQL(): SQL {\n\t\t\treturn this.sql;\n\t\t}\n\n\t\t/** @internal */\n\t\tclone() {\n\t\t\treturn new Aliased(this.sql, this.fieldAlias);\n\t\t}\n\t}\n}\n\nexport class Placeholder<TName extends string = string, TValue = any> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Placeholder';\n\n\tdeclare protected: TValue;\n\n\tconstructor(readonly name: TName) {}\n\n\tgetSQL(): SQL {\n\t\treturn new SQL([this]);\n\t}\n}\n\n/** @deprecated Use `sql.placeholder` instead. */\nexport function placeholder<TName extends string>(name: TName): Placeholder<TName> {\n\treturn new Placeholder(name);\n}\n\nexport function fillPlaceholders(params: unknown[], values: Record<string, unknown>): unknown[] {\n\treturn params.map((p) => {\n\t\tif (is(p, Placeholder)) {\n\t\t\tif (!(p.name in values)) {\n\t\t\t\tthrow new Error(`No value for placeholder \"${p.name}\" was provided`);\n\t\t\t}\n\n\t\t\treturn values[p.name];\n\t\t}\n\n\t\tif (is(p, Param) && is(p.value, Placeholder)) {\n\t\t\tif (!(p.value.name in values)) {\n\t\t\t\tthrow new Error(`No value for placeholder \"${p.value.name}\" was provided`);\n\t\t\t}\n\n\t\t\treturn p.encoder.mapToDriverValue(values[p.value.name]);\n\t\t}\n\n\t\treturn p;\n\t});\n}\n\nexport type ColumnsSelection = Record<string, unknown>;\n\nconst IsDrizzleView = Symbol.for('drizzle:IsDrizzleView');\n\nexport abstract class View<\n\tTName extends string = string,\n\tTExisting extends boolean = boolean,\n\tTSelection extends ColumnsSelection = ColumnsSelection,\n> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'View';\n\n\tdeclare _: {\n\t\tbrand: 'View';\n\t\tviewBrand: string;\n\t\tname: TName;\n\t\texisting: TExisting;\n\t\tselectedFields: TSelection;\n\t};\n\n\t/** @internal */\n\t[ViewBaseConfig]: {\n\t\tname: TName;\n\t\toriginalName: TName;\n\t\tschema: string | undefined;\n\t\tselectedFields: ColumnsSelection;\n\t\tisExisting: TExisting;\n\t\tquery: TExisting extends true ? undefined : SQL;\n\t\tisAlias: boolean;\n\t};\n\n\t/** @internal */\n\t[IsDrizzleView] = true;\n\n\tdeclare readonly $inferSelect: InferSelectViewModel<View<Assume<TName, string>, TExisting, TSelection>>;\n\n\tconstructor(\n\t\t{ name, schema, selectedFields, query }: {\n\t\t\tname: TName;\n\t\t\tschema: string | undefined;\n\t\t\tselectedFields: ColumnsSelection;\n\t\t\tquery: SQL | undefined;\n\t\t},\n\t) {\n\t\tthis[ViewBaseConfig] = {\n\t\t\tname,\n\t\t\toriginalName: name,\n\t\t\tschema,\n\t\t\tselectedFields,\n\t\t\tquery: query as (TExisting extends true ? undefined : SQL),\n\t\t\tisExisting: !query as TExisting,\n\t\t\tisAlias: false,\n\t\t};\n\t}\n\n\tgetSQL(): SQL<unknown> {\n\t\treturn new SQL([this]);\n\t}\n}\n\nexport function isView(view: unknown): view is View {\n\treturn typeof view === 'object' && view !== null && IsDrizzleView in view;\n}\n\nexport function getViewName<T extends View>(view: T): T['_']['name'] {\n\treturn view[ViewBaseConfig].name;\n}\n\nexport type InferSelectViewModel<TView extends View> =\n\tEqual<TView['_']['selectedFields'], { [x: string]: unknown }> extends true ? { [x: string]: unknown }\n\t\t: SelectResult<\n\t\t\tTView['_']['selectedFields'],\n\t\t\t'single',\n\t\t\tRecord<TView['_']['name'], 'not-null'>\n\t\t>;\n\n// Defined separately from the Column class to resolve circular dependency\nColumn.prototype.getSQL = function() {\n\treturn new SQL([this]);\n};\n\n// Defined separately from the Table class to resolve circular dependency\nTable.prototype.getSQL = function() {\n\treturn new SQL([this]);\n};\n\n// Defined separately from the Column class to resolve circular dependency\nSubquery.prototype.getSQL = function() {\n\treturn new SQL([this]);\n};\n","import { type AnyColumn, Column, type GetColumnData } from '~/column.ts';\nimport { is } from '~/entity.ts';\nimport { Table } from '~/table.ts';\nimport {\n\tisDriverValueEncoder,\n\tisSQLWrapper,\n\tParam,\n\tPlaceholder,\n\tSQL,\n\tsql,\n\ttype SQLChunk,\n\ttype SQLWrapper,\n\tStringChunk,\n\tView,\n} from '../sql.ts';\n\nexport function bindIfParam(value: unknown, column: SQLWrapper): SQLChunk {\n\tif (\n\t\tisDriverValueEncoder(column)\n\t\t&& !isSQLWrapper(value)\n\t\t&& !is(value, Param)\n\t\t&& !is(value, Placeholder)\n\t\t&& !is(value, Column)\n\t\t&& !is(value, Table)\n\t\t&& !is(value, View)\n\t) {\n\t\treturn new Param(value, column);\n\t}\n\treturn value as SQLChunk;\n}\n\nexport interface BinaryOperator {\n\t<TColumn extends Column>(\n\t\tleft: TColumn,\n\t\tright: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n\t): SQL;\n\t<T>(left: SQL.Aliased<T>, right: T | SQLWrapper): SQL;\n\t<T extends SQLWrapper>(\n\t\tleft: Exclude<T, SQL.Aliased | Column>,\n\t\tright: unknown,\n\t): SQL;\n}\n\n/**\n * Test that two values are equal.\n *\n * Remember that the SQL standard dictates that\n * two NULL values are not equal, so if you want to test\n * whether a value is null, you may want to use\n * `isNull` instead.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made by Ford\n * db.select().from(cars)\n *   .where(eq(cars.make, 'Ford'))\n * ```\n *\n * @see isNull for a way to test equality to NULL.\n */\nexport const eq: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} = ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test that two values are not equal.\n *\n * Remember that the SQL standard dictates that\n * two NULL values are not equal, so if you want to test\n * whether a value is not null, you may want to use\n * `isNotNull` instead.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars not made by Ford\n * db.select().from(cars)\n *   .where(ne(cars.make, 'Ford'))\n * ```\n *\n * @see isNotNull for a way to test whether a value is not null.\n */\nexport const ne: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} <> ${bindIfParam(right, left)}`;\n};\n\n/**\n * Combine a list of conditions with the `and` operator. Conditions\n * that are equal `undefined` are automatically ignored.\n *\n * ## Examples\n *\n * ```ts\n * db.select().from(cars)\n *   .where(\n *     and(\n *       eq(cars.make, 'Volvo'),\n *       eq(cars.year, 1950),\n *     )\n *   )\n * ```\n */\nexport function and(...conditions: (SQLWrapper | undefined)[]): SQL | undefined;\nexport function and(\n\t...unfilteredConditions: (SQLWrapper | undefined)[]\n): SQL | undefined {\n\tconst conditions = unfilteredConditions.filter(\n\t\t(c): c is Exclude<typeof c, undefined> => c !== undefined,\n\t);\n\n\tif (conditions.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tif (conditions.length === 1) {\n\t\treturn new SQL(conditions);\n\t}\n\n\treturn new SQL([\n\t\tnew StringChunk('('),\n\t\tsql.join(conditions, new StringChunk(' and ')),\n\t\tnew StringChunk(')'),\n\t]);\n}\n\n/**\n * Combine a list of conditions with the `or` operator. Conditions\n * that are equal `undefined` are automatically ignored.\n *\n * ## Examples\n *\n * ```ts\n * db.select().from(cars)\n *   .where(\n *     or(\n *       eq(cars.make, 'GM'),\n *       eq(cars.make, 'Ford'),\n *     )\n *   )\n * ```\n */\nexport function or(...conditions: (SQLWrapper | undefined)[]): SQL | undefined;\nexport function or(\n\t...unfilteredConditions: (SQLWrapper | undefined)[]\n): SQL | undefined {\n\tconst conditions = unfilteredConditions.filter(\n\t\t(c): c is Exclude<typeof c, undefined> => c !== undefined,\n\t);\n\n\tif (conditions.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tif (conditions.length === 1) {\n\t\treturn new SQL(conditions);\n\t}\n\n\treturn new SQL([\n\t\tnew StringChunk('('),\n\t\tsql.join(conditions, new StringChunk(' or ')),\n\t\tnew StringChunk(')'),\n\t]);\n}\n\n/**\n * Negate the meaning of an expression using the `not` keyword.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars _not_ made by GM or Ford.\n * db.select().from(cars)\n *   .where(not(inArray(cars.make, ['GM', 'Ford'])))\n * ```\n */\nexport function not(condition: SQLWrapper): SQL {\n\treturn sql`not ${condition}`;\n}\n\n/**\n * Test that the first expression passed is greater than\n * the second expression.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made after 2000.\n * db.select().from(cars)\n *   .where(gt(cars.year, 2000))\n * ```\n *\n * @see gte for greater-than-or-equal\n */\nexport const gt: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} > ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test that the first expression passed is greater than\n * or equal to the second expression. Use `gt` to\n * test whether an expression is strictly greater\n * than another.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made on or after 2000.\n * db.select().from(cars)\n *   .where(gte(cars.year, 2000))\n * ```\n *\n * @see gt for a strictly greater-than condition\n */\nexport const gte: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} >= ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test that the first expression passed is less than\n * the second expression.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made before 2000.\n * db.select().from(cars)\n *   .where(lt(cars.year, 2000))\n * ```\n *\n * @see lte for less-than-or-equal\n */\nexport const lt: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} < ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test that the first expression passed is less than\n * or equal to the second expression.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made before 2000.\n * db.select().from(cars)\n *   .where(lte(cars.year, 2000))\n * ```\n *\n * @see lt for a strictly less-than condition\n */\nexport const lte: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} <= ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test whether the first parameter, a column or expression,\n * has a value from a list passed as the second argument.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made by Ford or GM.\n * db.select().from(cars)\n *   .where(inArray(cars.make, ['Ford', 'GM']))\n * ```\n *\n * @see notInArray for the inverse of this test\n */\nexport function inArray<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function inArray<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function inArray<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function inArray(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\treturn sql`false`;\n\t\t}\n\t\treturn sql`${column} in ${values.map((v) => bindIfParam(v, column))}`;\n\t}\n\n\treturn sql`${column} in ${bindIfParam(values, column)}`;\n}\n\n/**\n * Test whether the first parameter, a column or expression,\n * has a value that is not present in a list passed as the\n * second argument.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made by any company except Ford or GM.\n * db.select().from(cars)\n *   .where(notInArray(cars.make, ['Ford', 'GM']))\n * ```\n *\n * @see inArray for the inverse of this test\n */\nexport function notInArray<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function notInArray<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function notInArray<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function notInArray(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\treturn sql`true`;\n\t\t}\n\t\treturn sql`${column} not in ${values.map((v) => bindIfParam(v, column))}`;\n\t}\n\n\treturn sql`${column} not in ${bindIfParam(values, column)}`;\n}\n\n/**\n * Test whether an expression is NULL. By the SQL standard,\n * NULL is neither equal nor not equal to itself, so\n * it's recommended to use `isNull` and `notIsNull` for\n * comparisons to NULL.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars that have no discontinuedAt date.\n * db.select().from(cars)\n *   .where(isNull(cars.discontinuedAt))\n * ```\n *\n * @see isNotNull for the inverse of this test\n */\nexport function isNull(value: SQLWrapper): SQL {\n\treturn sql`${value} is null`;\n}\n\n/**\n * Test whether an expression is not NULL. By the SQL standard,\n * NULL is neither equal nor not equal to itself, so\n * it's recommended to use `isNull` and `notIsNull` for\n * comparisons to NULL.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars that have been discontinued.\n * db.select().from(cars)\n *   .where(isNotNull(cars.discontinuedAt))\n * ```\n *\n * @see isNull for the inverse of this test\n */\nexport function isNotNull(value: SQLWrapper): SQL {\n\treturn sql`${value} is not null`;\n}\n\n/**\n * Test whether a subquery evaluates to have any rows.\n *\n * ## Examples\n *\n * ```ts\n * // Users whose `homeCity` column has a match in a cities\n * // table.\n * db\n *   .select()\n *   .from(users)\n *   .where(\n *     exists(db.select()\n *       .from(cities)\n *       .where(eq(users.homeCity, cities.id))),\n *   );\n * ```\n *\n * @see notExists for the inverse of this test\n */\nexport function exists(subquery: SQLWrapper): SQL {\n\treturn sql`exists ${subquery}`;\n}\n\n/**\n * Test whether a subquery doesn't include any result\n * rows.\n *\n * ## Examples\n *\n * ```ts\n * // Users whose `homeCity` column doesn't match\n * // a row in the cities table.\n * db\n *   .select()\n *   .from(users)\n *   .where(\n *     notExists(db.select()\n *       .from(cities)\n *       .where(eq(users.homeCity, cities.id))),\n *   );\n * ```\n *\n * @see exists for the inverse of this test\n */\nexport function notExists(subquery: SQLWrapper): SQL {\n\treturn sql`not exists ${subquery}`;\n}\n\n/**\n * Test whether an expression is between two values. This\n * is an easier way to express range tests, which would be\n * expressed mathematically as `x <= a <= y` but in SQL\n * would have to be like `a >= x AND a <= y`.\n *\n * Between is inclusive of the endpoints: if `column`\n * is equal to `min` or `max`, it will be TRUE.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made between 1990 and 2000\n * db.select().from(cars)\n *   .where(between(cars.year, 1990, 2000))\n * ```\n *\n * @see notBetween for the inverse of this test\n */\nexport function between<T>(\n\tcolumn: SQL.Aliased,\n\tmin: T | SQLWrapper,\n\tmax: T | SQLWrapper,\n): SQL;\nexport function between<TColumn extends AnyColumn>(\n\tcolumn: TColumn,\n\tmin: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n\tmax: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n): SQL;\nexport function between<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tmin: unknown,\n\tmax: unknown,\n): SQL;\nexport function between(column: SQLWrapper, min: unknown, max: unknown): SQL {\n\treturn sql`${column} between ${bindIfParam(min, column)} and ${\n\t\tbindIfParam(\n\t\t\tmax,\n\t\t\tcolumn,\n\t\t)\n\t}`;\n}\n\n/**\n * Test whether an expression is not between two values.\n *\n * This, like `between`, includes its endpoints, so if\n * the `column` is equal to `min` or `max`, in this case\n * it will evaluate to FALSE.\n *\n * ## Examples\n *\n * ```ts\n * // Exclude cars made in the 1970s\n * db.select().from(cars)\n *   .where(notBetween(cars.year, 1970, 1979))\n * ```\n *\n * @see between for the inverse of this test\n */\nexport function notBetween<T>(\n\tcolumn: SQL.Aliased,\n\tmin: T | SQLWrapper,\n\tmax: T | SQLWrapper,\n): SQL;\nexport function notBetween<TColumn extends AnyColumn>(\n\tcolumn: TColumn,\n\tmin: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n\tmax: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n): SQL;\nexport function notBetween<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tmin: unknown,\n\tmax: unknown,\n): SQL;\nexport function notBetween(\n\tcolumn: SQLWrapper,\n\tmin: unknown,\n\tmax: unknown,\n): SQL {\n\treturn sql`${column} not between ${\n\t\tbindIfParam(\n\t\t\tmin,\n\t\t\tcolumn,\n\t\t)\n\t} and ${bindIfParam(max, column)}`;\n}\n\n/**\n * Compare a column to a pattern, which can include `%` and `_`\n * characters to match multiple variations. Including `%`\n * in the pattern matches zero or more characters, and including\n * `_` will match a single character.\n *\n * ## Examples\n *\n * ```ts\n * // Select all cars with 'Turbo' in their names.\n * db.select().from(cars)\n *   .where(like(cars.name, '%Turbo%'))\n * ```\n *\n * @see ilike for a case-insensitive version of this condition\n */\nexport function like(column: Column | SQL.Aliased | SQL, value: string | SQLWrapper): SQL {\n\treturn sql`${column} like ${value}`;\n}\n\n/**\n * The inverse of like - this tests that a given column\n * does not match a pattern, which can include `%` and `_`\n * characters to match multiple variations. Including `%`\n * in the pattern matches zero or more characters, and including\n * `_` will match a single character.\n *\n * ## Examples\n *\n * ```ts\n * // Select all cars that don't have \"ROver\" in their name.\n * db.select().from(cars)\n *   .where(notLike(cars.name, '%Rover%'))\n * ```\n *\n * @see like for the inverse condition\n * @see notIlike for a case-insensitive version of this condition\n */\nexport function notLike(column: Column | SQL.Aliased | SQL, value: string | SQLWrapper): SQL {\n\treturn sql`${column} not like ${value}`;\n}\n\n/**\n * Case-insensitively compare a column to a pattern,\n * which can include `%` and `_`\n * characters to match multiple variations. Including `%`\n * in the pattern matches zero or more characters, and including\n * `_` will match a single character.\n *\n * Unlike like, this performs a case-insensitive comparison.\n *\n * ## Examples\n *\n * ```ts\n * // Select all cars with 'Turbo' in their names.\n * db.select().from(cars)\n *   .where(ilike(cars.name, '%Turbo%'))\n * ```\n *\n * @see like for a case-sensitive version of this condition\n */\nexport function ilike(column: Column | SQL.Aliased | SQL, value: string | SQLWrapper): SQL {\n\treturn sql`${column} ilike ${value}`;\n}\n\n/**\n * The inverse of ilike - this case-insensitively tests that a given column\n * does not match a pattern, which can include `%` and `_`\n * characters to match multiple variations. Including `%`\n * in the pattern matches zero or more characters, and including\n * `_` will match a single character.\n *\n * ## Examples\n *\n * ```ts\n * // Select all cars that don't have \"Rover\" in their name.\n * db.select().from(cars)\n *   .where(notLike(cars.name, '%Rover%'))\n * ```\n *\n * @see ilike for the inverse condition\n * @see notLike for a case-sensitive version of this condition\n */\nexport function notIlike(column: Column | SQL.Aliased | SQL, value: string | SQLWrapper): SQL {\n\treturn sql`${column} not ilike ${value}`;\n}\n\n/**\n * Test that a column or expression contains all elements of\n * the list passed as the second argument.\n *\n * ## Throws\n *\n * The argument passed in the second array can't be empty:\n * if an empty is provided, this method will throw.\n *\n * ## Examples\n *\n * ```ts\n * // Select posts where its tags contain \"Typescript\" and \"ORM\".\n * db.select().from(posts)\n *   .where(arrayContains(posts.tags, ['Typescript', 'ORM']))\n * ```\n *\n * @see arrayContained to find if an array contains all elements of a column or expression\n * @see arrayOverlaps to find if a column or expression contains any elements of an array\n */\nexport function arrayContains<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayContains<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayContains<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function arrayContains(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\tthrow new Error('arrayContains requires at least one value');\n\t\t}\n\t\tconst array = sql`${bindIfParam(values, column)}`;\n\t\treturn sql`${column} @> ${array}`;\n\t}\n\n\treturn sql`${column} @> ${bindIfParam(values, column)}`;\n}\n\n/**\n * Test that the list passed as the second argument contains\n * all elements of a column or expression.\n *\n * ## Throws\n *\n * The argument passed in the second array can't be empty:\n * if an empty is provided, this method will throw.\n *\n * ## Examples\n *\n * ```ts\n * // Select posts where its tags contain \"Typescript\", \"ORM\" or both,\n * // but filtering posts that have additional tags.\n * db.select().from(posts)\n *   .where(arrayContained(posts.tags, ['Typescript', 'ORM']))\n * ```\n *\n * @see arrayContains to find if a column or expression contains all elements of an array\n * @see arrayOverlaps to find if a column or expression contains any elements of an array\n */\nexport function arrayContained<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayContained<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayContained<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function arrayContained(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\tthrow new Error('arrayContained requires at least one value');\n\t\t}\n\t\tconst array = sql`${bindIfParam(values, column)}`;\n\t\treturn sql`${column} <@ ${array}`;\n\t}\n\n\treturn sql`${column} <@ ${bindIfParam(values, column)}`;\n}\n\n/**\n * Test that a column or expression contains any elements of\n * the list passed as the second argument.\n *\n * ## Throws\n *\n * The argument passed in the second array can't be empty:\n * if an empty is provided, this method will throw.\n *\n * ## Examples\n *\n * ```ts\n * // Select posts where its tags contain \"Typescript\", \"ORM\" or both.\n * db.select().from(posts)\n *   .where(arrayOverlaps(posts.tags, ['Typescript', 'ORM']))\n * ```\n *\n * @see arrayContains to find if a column or expression contains all elements of an array\n * @see arrayContained to find if an array contains all elements of a column or expression\n */\nexport function arrayOverlaps<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayOverlaps<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayOverlaps<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function arrayOverlaps(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\tthrow new Error('arrayOverlaps requires at least one value');\n\t\t}\n\t\tconst array = sql`${bindIfParam(values, column)}`;\n\t\treturn sql`${column} && ${array}`;\n\t}\n\n\treturn sql`${column} && ${bindIfParam(values, column)}`;\n}\n","import type { AnyColumn } from './column.ts';\nimport { Column } from './column.ts';\nimport { is } from './entity.ts';\nimport type { Logger } from './logger.ts';\nimport type { SelectedFieldsOrdered } from './operations.ts';\nimport type { TableLike } from './query-builders/select.types.ts';\nimport { Param, SQL, View } from './sql/sql.ts';\nimport type { DriverValueDecoder } from './sql/sql.ts';\nimport { Subquery } from './subquery.ts';\nimport { getTableName, Table } from './table.ts';\nimport { ViewBaseConfig } from './view-common.ts';\n\n/** @internal */\nexport function mapResultRow<TResult>(\n\tcolumns: SelectedFieldsOrdered<AnyColumn>,\n\trow: unknown[],\n\tjoinsNotNullableMap: Record<string, boolean> | undefined,\n): TResult {\n\t// Key -> nested object key, value -> table name if all fields in the nested object are from the same table, false otherwise\n\tconst nullifyMap: Record<string, string | false> = {};\n\n\tconst result = columns.reduce<Record<string, any>>(\n\t\t(result, { path, field }, columnIndex) => {\n\t\t\tlet decoder: DriverValueDecoder<unknown, unknown>;\n\t\t\tif (is(field, Column)) {\n\t\t\t\tdecoder = field;\n\t\t\t} else if (is(field, SQL)) {\n\t\t\t\tdecoder = field.decoder;\n\t\t\t} else {\n\t\t\t\tdecoder = field.sql.decoder;\n\t\t\t}\n\t\t\tlet node = result;\n\t\t\tfor (const [pathChunkIndex, pathChunk] of path.entries()) {\n\t\t\t\tif (pathChunkIndex < path.length - 1) {\n\t\t\t\t\tif (!(pathChunk in node)) {\n\t\t\t\t\t\tnode[pathChunk] = {};\n\t\t\t\t\t}\n\t\t\t\t\tnode = node[pathChunk];\n\t\t\t\t} else {\n\t\t\t\t\tconst rawValue = row[columnIndex]!;\n\t\t\t\t\tconst value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);\n\n\t\t\t\t\tif (joinsNotNullableMap && is(field, Column) && path.length === 2) {\n\t\t\t\t\t\tconst objectName = path[0]!;\n\t\t\t\t\t\tif (!(objectName in nullifyMap)) {\n\t\t\t\t\t\t\tnullifyMap[objectName] = value === null ? getTableName(field.table) : false;\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\ttypeof nullifyMap[objectName] === 'string' && nullifyMap[objectName] !== getTableName(field.table)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tnullifyMap[objectName] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\t{},\n\t);\n\n\t// Nullify all nested objects from nullifyMap that are nullable\n\tif (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {\n\t\tfor (const [objectName, tableName] of Object.entries(nullifyMap)) {\n\t\t\tif (typeof tableName === 'string' && !joinsNotNullableMap[tableName]) {\n\t\t\t\tresult[objectName] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result as TResult;\n}\n\n/** @internal */\nexport function orderSelectedFields<TColumn extends AnyColumn>(\n\tfields: Record<string, unknown>,\n\tpathPrefix?: string[],\n): SelectedFieldsOrdered<TColumn> {\n\treturn Object.entries(fields).reduce<SelectedFieldsOrdered<AnyColumn>>((result, [name, field]) => {\n\t\tif (typeof name !== 'string') {\n\t\t\treturn result;\n\t\t}\n\n\t\tconst newPath = pathPrefix ? [...pathPrefix, name] : [name];\n\t\tif (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {\n\t\t\tresult.push({ path: newPath, field });\n\t\t} else if (is(field, Table)) {\n\t\t\tresult.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));\n\t\t} else {\n\t\t\tresult.push(...orderSelectedFields(field as Record<string, unknown>, newPath));\n\t\t}\n\t\treturn result;\n\t}, []) as SelectedFieldsOrdered<TColumn>;\n}\n\nexport function haveSameKeys(left: Record<string, unknown>, right: Record<string, unknown>) {\n\tconst leftKeys = Object.keys(left);\n\tconst rightKeys = Object.keys(right);\n\n\tif (leftKeys.length !== rightKeys.length) {\n\t\treturn false;\n\t}\n\n\tfor (const [index, key] of leftKeys.entries()) {\n\t\tif (key !== rightKeys[index]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/** @internal */\nexport function mapUpdateSet(table: Table, values: Record<string, unknown>): UpdateSet {\n\tconst entries: [string, UpdateSet[string]][] = Object.entries(values)\n\t\t.filter(([, value]) => value !== undefined)\n\t\t.map(([key, value]) => {\n\t\t\t// eslint-disable-next-line unicorn/prefer-ternary\n\t\t\tif (is(value, SQL) || is(value, Column)) {\n\t\t\t\treturn [key, value];\n\t\t\t} else {\n\t\t\t\treturn [key, new Param(value, table[Table.Symbol.Columns][key])];\n\t\t\t}\n\t\t});\n\n\tif (entries.length === 0) {\n\t\tthrow new Error('No values to set');\n\t}\n\n\treturn Object.fromEntries(entries);\n}\n\nexport type UpdateSet = Record<string, SQL | Param | AnyColumn | null | undefined>;\n\nexport type OneOrMany<T> = T | T[];\n\nexport type Update<T, TUpdate> =\n\t& {\n\t\t[K in Exclude<keyof T, keyof TUpdate>]: T[K];\n\t}\n\t& TUpdate;\n\nexport type Simplify<T> =\n\t& {\n\t\t// @ts-ignore - \"Type parameter 'K' has a circular constraint\", not sure why\n\t\t[K in keyof T]: T[K];\n\t}\n\t& {};\n\nexport type SimplifyMappedType<T> = [T] extends [unknown] ? T : never;\n\nexport type ShallowRecord<K extends keyof any, T> = SimplifyMappedType<{ [P in K]: T }>;\n\nexport type Assume<T, U> = T extends U ? T : U;\n\nexport type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends (<T>() => T extends Y ? 1 : 2) ? true : false;\n\nexport interface DrizzleTypeError<T extends string> {\n\t$drizzleTypeError: T;\n}\n\nexport type ValueOrArray<T> = T | T[];\n\n/** @internal */\nexport function applyMixins(baseClass: any, extendedClasses: any[]) {\n\tfor (const extendedClass of extendedClasses) {\n\t\tfor (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {\n\t\t\tif (name === 'constructor') continue;\n\n\t\t\tObject.defineProperty(\n\t\t\t\tbaseClass.prototype,\n\t\t\t\tname,\n\t\t\t\tObject.getOwnPropertyDescriptor(extendedClass.prototype, name) || Object.create(null),\n\t\t\t);\n\t\t}\n\t}\n}\n\nexport type Or<T1, T2> = T1 extends true ? true : T2 extends true ? true : false;\n\nexport type IfThenElse<If, Then, Else> = If extends true ? Then : Else;\n\nexport type PromiseOf<T> = T extends Promise<infer U> ? U : T;\n\nexport type Writable<T> = {\n\t-readonly [P in keyof T]: T[P];\n};\n\nexport function getTableColumns<T extends Table>(table: T): T['_']['columns'] {\n\treturn table[Table.Symbol.Columns];\n}\n\nexport function getViewSelectedFields<T extends View>(view: T): T['_']['selectedFields'] {\n\treturn view[ViewBaseConfig].selectedFields;\n}\n\n/** @internal */\nexport function getTableLikeName(table: TableLike): string | undefined {\n\treturn is(table, Subquery)\n\t\t? table._.alias\n\t\t: is(table, View)\n\t\t? table[ViewBaseConfig].name\n\t\t: is(table, SQL)\n\t\t? undefined\n\t\t: table[Table.Symbol.IsAlias]\n\t\t? table[Table.Symbol.Name]\n\t\t: table[Table.Symbol.BaseName];\n}\n\nexport type ColumnsWithTable<\n\tTTableName extends string,\n\tTForeignTableName extends string,\n\tTColumns extends AnyColumn<{ tableName: TTableName }>[],\n> = { [Key in keyof TColumns]: AnyColumn<{ tableName: TForeignTableName }> };\n\nexport type Casing = 'snake_case' | 'camelCase';\n\nexport interface DrizzleConfig<TSchema extends Record<string, unknown> = Record<string, never>> {\n\tlogger?: boolean | Logger;\n\tschema?: TSchema;\n\tcasing?: Casing;\n}\nexport type ValidateShape<T, ValidShape, TResult = T> = T extends ValidShape\n\t? Exclude<keyof T, keyof ValidShape> extends never ? TResult\n\t: DrizzleTypeError<\n\t\t`Invalid key(s): ${Exclude<(keyof T) & (string | number | bigint | boolean | null | undefined), keyof ValidShape>}`\n\t>\n\t: never;\n\nexport type KnownKeysOnly<T, U> = {\n\t[K in keyof T]: K extends keyof U ? T[K] : never;\n};\n\nexport type IsAny<T> = 0 extends (1 & T) ? true : false;\n\n/** @internal */\nexport function getColumnNameAndConfig<\n\tTConfig extends Record<string, any> | undefined,\n>(a: string | TConfig | undefined, b: TConfig | undefined) {\n\treturn {\n\t\tname: typeof a === 'string' && a.length > 0 ? a : '' as string,\n\t\tconfig: typeof a === 'object' ? a : b as TConfig,\n\t};\n}\n\nexport type IfNotImported<T, Y, N> = unknown extends T ? Y : N;\n\nexport type ImportTypeError<TPackageName extends string> =\n\t`Please install \\`${TPackageName}\\` to allow Drizzle ORM to connect to the database`;\n\nexport type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Keys extends any\n\t? Required<Pick<T, Keys>> & Partial<Omit<T, Keys>>\n\t: never;\n\ntype ExpectedConfigShape = {\n\tlogger?: boolean | {\n\t\tlogQuery(query: string, params: unknown[]): void;\n\t};\n\tschema?: Record<string, never>;\n\tcasing?: 'snake_case' | 'camelCase';\n};\n\n// If this errors, you must update config shape checker function with new config specs\nconst _: DrizzleConfig = {} as ExpectedConfigShape;\nconst __: ExpectedConfigShape = {} as DrizzleConfig;\n\nexport function isConfig(data: any): boolean {\n\tif (typeof data !== 'object' || data === null) return false;\n\n\tif (data.constructor.name !== 'Object') return false;\n\n\tif ('logger' in data) {\n\t\tconst type = typeof data['logger'];\n\t\tif (\n\t\t\ttype !== 'boolean' && (type !== 'object' || typeof data['logger']['logQuery'] !== 'function')\n\t\t\t&& type !== 'undefined'\n\t\t) return false;\n\n\t\treturn true;\n\t}\n\n\tif ('schema' in data) {\n\t\tconst type = typeof data['logger'];\n\t\tif (type !== 'object' && type !== 'undefined') return false;\n\n\t\treturn true;\n\t}\n\n\tif ('casing' in data) {\n\t\tconst type = typeof data['logger'];\n\t\tif (type !== 'string' && type !== 'undefined') return false;\n\n\t\treturn true;\n\t}\n\n\tif ('mode' in data) {\n\t\tif (data['mode'] !== 'default' || data['mode'] !== 'planetscale' || data['mode'] !== undefined) return false;\n\n\t\treturn true;\n\t}\n\n\tif ('connection' in data) {\n\t\tconst type = typeof data['connection'];\n\t\tif (type !== 'string' && type !== 'object' && type !== 'undefined') return false;\n\n\t\treturn true;\n\t}\n\n\tif ('client' in data) {\n\t\tconst type = typeof data['client'];\n\t\tif (type !== 'object' && type !== 'function' && type !== 'undefined') return false;\n\n\t\treturn true;\n\t}\n\n\tif (Object.keys(data).length === 0) return true;\n\n\treturn false;\n}\n\nexport type NeonAuthToken = string | (() => string | Promise<string>);\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport type { SQL } from '~/sql/sql.ts';\nimport { type Equal, getColumnNameAndConfig } from '~/utils.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type ConvertCustomConfig<TName extends string, T extends Partial<CustomTypeValues>> =\n\t& {\n\t\tname: TName;\n\t\tdataType: 'custom';\n\t\tcolumnType: 'PgCustomColumn';\n\t\tdata: T['data'];\n\t\tdriverParam: T['driverData'];\n\t\tenumValues: undefined;\n\t}\n\t& (T['notNull'] extends true ? { notNull: true } : {})\n\t& (T['default'] extends true ? { hasDefault: true } : {});\n\nexport interface PgCustomColumnInnerConfig {\n\tcustomTypeValues: CustomTypeValues;\n}\n\nexport class PgCustomColumnBuilder<T extends ColumnBuilderBaseConfig<'custom', 'PgCustomColumn'>>\n\textends PgColumnBuilder<\n\t\tT,\n\t\t{\n\t\t\tfieldConfig: CustomTypeValues['config'];\n\t\t\tcustomTypeParams: CustomTypeParams<any>;\n\t\t},\n\t\t{\n\t\t\tpgColumnBuilderBrand: 'PgCustomColumnBuilderBrand';\n\t\t}\n\t>\n{\n\tstatic override readonly [entityKind]: string = 'PgCustomColumnBuilder';\n\n\tconstructor(\n\t\tname: T['name'],\n\t\tfieldConfig: CustomTypeValues['config'],\n\t\tcustomTypeParams: CustomTypeParams<any>,\n\t) {\n\t\tsuper(name, 'custom', 'PgCustomColumn');\n\t\tthis.config.fieldConfig = fieldConfig;\n\t\tthis.config.customTypeParams = customTypeParams;\n\t}\n\n\t/** @internal */\n\tbuild<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgCustomColumn<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgCustomColumn<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgCustomColumn<T extends ColumnBaseConfig<'custom', 'PgCustomColumn'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgCustomColumn';\n\n\tprivate sqlName: string;\n\tprivate mapTo?: (value: T['data']) => T['driverParam'];\n\tprivate mapFrom?: (value: T['driverParam']) => T['data'];\n\n\tconstructor(\n\t\ttable: AnyPgTable<{ name: T['tableName'] }>,\n\t\tconfig: PgCustomColumnBuilder<T>['config'],\n\t) {\n\t\tsuper(table, config);\n\t\tthis.sqlName = config.customTypeParams.dataType(config.fieldConfig);\n\t\tthis.mapTo = config.customTypeParams.toDriver;\n\t\tthis.mapFrom = config.customTypeParams.fromDriver;\n\t}\n\n\tgetSQLType(): string {\n\t\treturn this.sqlName;\n\t}\n\n\toverride mapFromDriverValue(value: T['driverParam']): T['data'] {\n\t\treturn typeof this.mapFrom === 'function' ? this.mapFrom(value) : value as T['data'];\n\t}\n\n\toverride mapToDriverValue(value: T['data']): T['driverParam'] {\n\t\treturn typeof this.mapTo === 'function' ? this.mapTo(value) : value as T['data'];\n\t}\n}\n\nexport type CustomTypeValues = {\n\t/**\n\t * Required type for custom column, that will infer proper type model\n\t *\n\t * Examples:\n\t *\n\t * If you want your column to be `string` type after selecting/or on inserting - use `data: string`. Like `text`, `varchar`\n\t *\n\t * If you want your column to be `number` type after selecting/or on inserting - use `data: number`. Like `integer`\n\t */\n\tdata: unknown;\n\n\t/**\n\t * Type helper, that represents what type database driver is accepting for specific database data type\n\t */\n\tdriverData?: unknown;\n\n\t/**\n\t * What config type should be used for {@link CustomTypeParams} `dataType` generation\n\t */\n\tconfig?: Record<string, any>;\n\n\t/**\n\t * Whether the config argument should be required or not\n\t * @default false\n\t */\n\tconfigRequired?: boolean;\n\n\t/**\n\t * If your custom data type should be notNull by default you can use `notNull: true`\n\t *\n\t * @example\n\t * const customSerial = customType<{ data: number, notNull: true, default: true }>({\n\t * \t  dataType() {\n\t * \t    return 'serial';\n\t *    },\n\t * });\n\t */\n\tnotNull?: boolean;\n\n\t/**\n\t * If your custom data type has default you can use `default: true`\n\t *\n\t * @example\n\t * const customSerial = customType<{ data: number, notNull: true, default: true }>({\n\t * \t  dataType() {\n\t * \t    return 'serial';\n\t *    },\n\t * });\n\t */\n\tdefault?: boolean;\n};\n\nexport interface CustomTypeParams<T extends CustomTypeValues> {\n\t/**\n\t * Database data type string representation, that is used for migrations\n\t * @example\n\t * ```\n\t * `jsonb`, `text`\n\t * ```\n\t *\n\t * If database data type needs additional params you can use them from `config` param\n\t * @example\n\t * ```\n\t * `varchar(256)`, `numeric(2,3)`\n\t * ```\n\t *\n\t * To make `config` be of specific type please use config generic in {@link CustomTypeValues}\n\t *\n\t * @example\n\t * Usage example\n\t * ```\n\t *   dataType() {\n\t *     return 'boolean';\n\t *   },\n\t * ```\n\t * Or\n\t * ```\n\t *   dataType(config) {\n\t * \t   return typeof config.length !== 'undefined' ? `varchar(${config.length})` : `varchar`;\n\t * \t }\n\t * ```\n\t */\n\tdataType: (config: T['config'] | (Equal<T['configRequired'], true> extends true ? never : undefined)) => string;\n\n\t/**\n\t * Optional mapping function, between user input and driver\n\t * @example\n\t * For example, when using jsonb we need to map JS/TS object to string before writing to database\n\t * ```\n\t * toDriver(value: TData): string {\n\t * \t return JSON.stringify(value);\n\t * }\n\t * ```\n\t */\n\ttoDriver?: (value: T['data']) => T['driverData'] | SQL;\n\n\t/**\n\t * Optional mapping function, that is responsible for data mapping from database to JS/TS code\n\t * @example\n\t * For example, when using timestamp we need to map string Date representation to JS Date\n\t * ```\n\t * fromDriver(value: string): Date {\n\t * \treturn new Date(value);\n\t * },\n\t * ```\n\t */\n\tfromDriver?: (value: T['driverData']) => T['data'];\n}\n\n/**\n * Custom pg database data type generator\n */\nexport function customType<T extends CustomTypeValues = CustomTypeValues>(\n\tcustomTypeParams: CustomTypeParams<T>,\n): Equal<T['configRequired'], true> extends true ? {\n\t\t<TConfig extends Record<string, any> & T['config']>(\n\t\t\tfieldConfig: TConfig,\n\t\t): PgCustomColumnBuilder<ConvertCustomConfig<'', T>>;\n\t\t<TName extends string>(\n\t\t\tdbName: TName,\n\t\t\tfieldConfig: T['config'],\n\t\t): PgCustomColumnBuilder<ConvertCustomConfig<TName, T>>;\n\t}\n\t: {\n\t\t(): PgCustomColumnBuilder<ConvertCustomConfig<'', T>>;\n\t\t<TConfig extends Record<string, any> & T['config']>(\n\t\t\tfieldConfig?: TConfig,\n\t\t): PgCustomColumnBuilder<ConvertCustomConfig<'', T>>;\n\t\t<TName extends string>(\n\t\t\tdbName: TName,\n\t\t\tfieldConfig?: T['config'],\n\t\t): PgCustomColumnBuilder<ConvertCustomConfig<TName, T>>;\n\t}\n{\n\treturn <TName extends string>(\n\t\ta?: TName | T['config'],\n\t\tb?: T['config'],\n\t): PgCustomColumnBuilder<ConvertCustomConfig<TName, T>> => {\n\t\tconst { name, config } = getColumnNameAndConfig<T['config']>(a, b);\n\t\treturn new PgCustomColumnBuilder(name as ConvertCustomConfig<TName, T>['name'], config, customTypeParams);\n\t};\n}\n","/**\n * @packageDocumentation\n *\n *  @groupDescription Measurement Functions\n * These functions compute measurements of distance, area and angles.\n * There are also functions to compute geometry values determined by measurements.\n * {@link https://postgis.net/docs/reference.html#Measurement_Functions}\n *\n * @groupDescription Geometry Inputs\n * These functions create geometry objects from various textual or binary formats.\n * {@link https://postgis.net/docs/reference.html#Geometry_Inputs}\n *\n * @groupDescription Geometry Outputs\n * These functions convert geometry objects into various textual or binary formats.\n * {@link https://postgis.net/docs/reference.html#Geometry_Inputs}\n *\n * @groupDescription Geometry Validation\n * These functions test whether geometries are valid according to the OGC SFS standard.\n * They also provide information about the nature and location of invalidity.\n * {@link https://postgis.net/docs/reference.html#Geometry_Validation}\n *\n * @groupDescription Geometry Accessors\n * These functions return information about properties of specific geometry objects.\n * {@link https://postgis.net/docs/reference.html#Geometry_Accessors}\n */\n\nimport { fromDriver } from \"~/models\";\nimport { type SQL, sql, type SQLWrapper } from \"drizzle-orm\";\nimport { gisExtensionSchema } from \"~/config\";\nimport type * as GeoJSON from \"~/geojsonTypes\";\n\n/** Returns the area of a polygonal geometry.\n *\n * For geometry types a 2D Cartesian (planar) area is computed, with units specified by the SRID.\n * For geography types by default area is determined on a spheroid with units in square meters.\n *\n * @group Measurement Functions\n * @link https://postgis.net/docs/ST_Area.html\n */\nexport function area(expression: SQLWrapper): SQL<number> {\n  return sql`${gisExtensionSchema}ST_Area(${expression})`.mapWith(Number);\n}\n\n/** Returns the 2-dimensional point on geom1 that is closest to geom2.\n *\n * This is the first point of the shortest line between the geometries (as computed by ST_ShortestLine).\n *\n * @group Measurement Functions\n * @link https://postgis.net/docs/ST_ClosestPoint.html\n */\nexport function closestPoint(\n  geom1: SQLWrapper,\n  geom2: SQLWrapper\n): SQL<GeoJSON.Point> {\n  return sql`${gisExtensionSchema}ST_ClosestPoint(${geom1}, ${geom2})`.mapWith(\n    fromDriver<GeoJSON.Point>\n  );\n}\n\n/** Constructs a PostGIS ST_Geometry object from the OGC Well-Known text representation.\n *\n * Inverse of {@link asText}\n *\n * @group Geometry Inputs\n * @link https://postgis.net/docs/ST_GeomFromText.html\n */\nexport function geomFromText(\n  expression: string | SQLWrapper\n): SQL<GeoJSON.Geometry> {\n  return sql`${gisExtensionSchema}ST_GeomFromText(${expression})`.mapWith(\n    fromDriver\n  );\n}\n\n/** Returns the OGC Well-Known Text (WKT) representation of the geometry/geography.\n *\n * Inverse of {@link geomFromText}\n *\n * @group Geometry Outputs\n * @link https://postgis.net/docs/ST_AsText.html\n */\nexport function asText(expression: string | SQLWrapper): SQL<string> {\n  return sql`${gisExtensionSchema}ST_AsText(${expression})`;\n}\n\n/** Return the X coordinate of the point, or NULL if not available. Input must be a point.\n *\n * @group Geometry Accessors\n * @link https://postgis.net/docs/ST_X.html\n */\nexport function x(expression: SQLWrapper): SQL<number | null> {\n  return sql`${gisExtensionSchema}ST_X(${expression})`.mapWith(Number);\n}\n\n/** Return the Y coordinate of the point, or NULL if not available. Input must be a point.\n *\n * @group Geometry Accessors\n * @link https://postgis.net/docs/ST_Y.html\n */\nexport function y(expression: SQLWrapper): SQL<number | null> {\n  return sql`${gisExtensionSchema}ST_Y(${expression})`.mapWith(Number);\n}\n\n/** Tests if an ST_Geometry value is well-formed and valid in 2D according to the OGC rules.\n *\n * @group Geometry Validation\n * @link https://postgis.net/docs/ST_IsValid.html\n */\nexport function isValid(geom1: SQLWrapper): SQL<boolean> {\n  return sql`${gisExtensionSchema}ST_IsValid(${geom1},0)`.mapWith(Boolean);\n}\n\n/** Returns text stating if a geometry is valid, or if invalid a reason why.\n *\n * @group Geometry Validation\n * @link https://postgis.net/docs/ST_IsValidReason.html\n */\nexport function isValidReason(geom1: SQLWrapper): SQL<string> {\n  return sql`${gisExtensionSchema}ST_IsValidReason(${geom1})`;\n}\n\n/** Constructs a PostGIS geometry object from the GeoJSON representation.\n *\n * ST_GeomFromGeoJSON works only for JSON Geometry fragments. It throws an error if you try to use it on a whole JSON document.\n *\n * @group Geometry Inputs\n * @link https://postgis.net/docs/ST_GeomFromGeoJSON.html\n */\nexport function geomFromGeoJSON(\n  expression: Record<string, unknown>\n): SQL<GeoJSON.Geometry> {\n  return sql`${gisExtensionSchema}ST_GeomFromGeoJSON(${JSON.stringify(\n    expression\n  )})`.mapWith(fromDriver);\n}\n\n/** Computes a GeoHash representation of a geometry.\n *\n * A GeoHash encodes a geographic Point into a text form that is sortable and searchable based on prefixing.\n * A shorter GeoHash is a less precise representation of a point. It can be thought of as a box that contains the point.\n *\n * @group Geometry Outputs\n * @link https://postgis.net/docs/ST_GeoHash.html\n */\nexport function geoHash(geom1: SQLWrapper, maxChars = 20): SQL<string> {\n  return sql`${gisExtensionSchema}ST_GeoHash(${geom1}, ${maxChars})`;\n}\n\n/** Return a derived geometry with measure elements linearly interpolated between the start and end points.\n *\n * If the geometry has no measure dimension, one is added.\n * If the geometry has a measure dimension, it is over-written with new values.\n * Only LINESTRINGS and MULTILINESTRINGS are supported..\n *\n * @group Linear Referencing\n * @link https://postgis.net/docs/manual-2.0/ST_AddMeasure.html\n */\nexport function addMeasure(\n  geom1: SQLWrapper,\n  measureStart: number,\n  measureEnd: number\n): SQL<string> {\n  return sql`${gisExtensionSchema}ST_AddMeasure(${geom1}, ${measureStart}, ${measureEnd})`;\n}\n","import { sql } from \"drizzle-orm\";\n\n/** Set this value to specify a namespace for accessing PostGIS\n *\n * Best to do it right when you instantiate your drizzle client.\n * @internal\n */\nexport let gisExtensionSchema = sql.raw(\"\");\n\n/** Can be used to set the schema for PostGIS in the case that it's not in the search path.\n *\n * @example config.setPostGISSchema(\"extensions\")\n *\n * @param schemaName name of the PostGIS schema\n *\n * @link https://www.postgresql.org/docs/current/ddl-schemas.html#DDL-SCHEMAS-PATH\n */\nexport function setPostGISSchema(schemaName: string) {\n  gisExtensionSchema = schemaName.length\n    ? sql.raw(`${schemaName}.`)\n    : sql.empty();\n}\n","/**\n * @packageDocumentation\n * Binary operators for use with GIS objects.\n *\n *  @groupDescription Bounding Box Operators\n * These operators calculate values related to the bounding boxes of their arguments.\n * {@link https://postgis.net/docs/reference.html#operators-bbox}\n *\n * @groupDescription Distance Operators\n * These operators calculate distance between their arguments\n * {@link https://postgis.net/docs/reference.html#operators-distance}\n */\n\nimport {\n  type SQLWrapper,\n  type SQL,\n  sql,\n  type BinaryOperator,\n  bindIfParam,\n} from \"drizzle-orm\";\nimport { gisExtensionSchema } from \"~/config\";\n\n/** && — Returns TRUE if A's 2D bounding box intersects B's 2D bounding box.\n *\n * @group Bounding Box Operators\n * @link https://postgis.net/docs/geometry_overlaps.html\n */\nexport const bboxOverlaps: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}&&) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** && — Returns TRUE if A's n-D bounding box intersects B's n-D bounding box.\n *\n * @group Bounding Box Operators\n * @link https://postgis.net/docs/geometry_overlaps_nd.html\n */\nexport const bboxOverlapsND: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}&&&) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** &< — Returns TRUE if A's bounding box overlaps or is to the left of B's.\n *\n * @group Bounding Box Operators\n * @link https://postgis.net/docs/ST_Geometry_Overleft.html\n */\nexport const bboxOverlapsOrLeft: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}&<) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** &<| — Returns TRUE if A's bounding box overlaps or is below B's.\n *\n * @group Bounding Box Operators\n * @link https://postgis.net/docs/ST_Geometry_Overbelow.html\n */\nexport const bboxOverlapsOrBelow: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}&<|) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** &> — Returns TRUE if A' bounding box overlaps or is to the right of B's.\n *\n * @group Bounding Box Operators\n * @link https://postgis.net/docs/ST_Geometry_Overright.html\n */\nexport const bboxOverlapsOrRight: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}&>) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** << — Returns TRUE if A's bounding box is strictly to the left of B's.\n *\n * @group Bounding Box Operators\n * @link https://postgis.net/docs/ST_Geometry_Left.html\n */\nexport const bboxLeft: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}<<) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** <<| — Returns TRUE if A's bounding box is strictly below B's.\n *\n * @group Bounding Box Operators\n * @link https://postgis.net/docs/ST_Geometry_Below.html\n */\nexport const bboxBelow: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}<<|) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** |&> — Returns TRUE if A's bounding box overlaps or is above B's.\n *\n * @group Bounding Box Operators\n * @link https://postgis.net/docs/ST_Geometry_Overabove.html\n */\nexport const bboxOverlapsOrAbove: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}|&>) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** |>> — Returns TRUE if A's bounding box is strictly above B's.\n *\n * @group Bounding Box Operators\n * @link https://postgis.net/docs/ST_Geometry_Above.html\n */\nexport const bboxAbove: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}|>>) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** >> — Returns TRUE if A's bounding box is strictly to the right of B's.\n *\n * @group Bounding Box Operators\n * @link https://postgis.net/docs/ST_Geometry_Right.html\n */\nexport const bboxRight: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}>>) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** = — Returns TRUE if the coordinates and coordinate order geometry/geography A are the same as the coordinates and coordinate order of geometry/geography B.\n *\n * @group Other Operators\n * @link https://postgis.net/docs/ST_Geometry_EQ.html\n */\nexport const eq: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}=) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** ~= — Returns TRUE if A's bounding box is the same as B's.\n *\n * @group Bounding Box Operators\n * @link https://postgis.net/docs/ST_Geometry_Same.html\n */\nexport const bboxSame: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}~=) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** @ — Returns TRUE if A's bounding box is contained by B's.\n *\n * @group Bounding Box Operators\n * @link https://postgis.net/docs/ST_Geometry_Contained.html\n */\nexport const bboxContained: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}@) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** ~ — Returns TRUE if A's bounding box contains B's.\n *\n * @group Bounding Box Operators\n * @link https://postgis.net/docs/ST_Geometry_Contain.html\n */\nexport const bboxContain: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}~) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** <-> — Returns the 2D distance between A and B.\n *\n * @group Distance Operators\n * @link https://postgis.net/docs/geometry_distance_knn.html\n */\nexport const distanceKNN: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL<number> => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}<->) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** |=| — Returns the distance between A and B trajectories at their closest point of approach.\n *\n * @group Distance Operators\n * @link https://postgis.net/docs/geometry_distance_cpa.html\n */\nexport const distanceCPA: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL<number> => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}|=|) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** <#> — Returns the 2D distance between A and B bounding boxes.\n *\n * @group Distance Operators\n * @link https://postgis.net/docs/geometry_distance_box.html\n */\nexport const distanceBox: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL<number> => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}<#>) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** <<->> — Returns the n-D distance between the centroids of A and B bounding boxes.\n *\n * @group Distance Operators\n * @link https://postgis.net/docs/geometry_distance_centroid_nd.html\n */\nexport const distanceCentroidND: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL<number> => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}<<->>) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n\n/** <<#>> — Returns the n-D distance between A and B bounding boxes.\n *\n * @group Distance Operators\n * @link https://postgis.net/docs/geometry_distance_box_nd.html\n */\nexport const distanceBoxND: BinaryOperator = (\n  left: SQLWrapper,\n  right: unknown\n): SQL<number> => {\n  return sql`${left} OPERATOR(${gisExtensionSchema}<<#>>) ${bindIfParam(\n    right,\n    left\n  )}`;\n};\n"]}