{"version":3,"sources":["../src/models.ts","../node_modules/.pnpm/drizzle-orm@0.40.0_postgres@3.4.4/node_modules/src/utils.ts","../node_modules/.pnpm/drizzle-orm@0.40.0_postgres@3.4.4/node_modules/src/pg-core/columns/custom.ts"],"names":["models_exports","__export","box2D","box2DfromDriver","fromDriver","geometry","geometryCollection","lineString","multiLineString","multiPoint","multiPolygon","point","polygon","getColumnNameAndConfig","a","b","PgCustomColumnBuilder","PgColumnBuilder","entityKind","name","fieldConfig","customTypeParams","table","PgCustomColumn","PgColumn","config","value","customType","wkx","dataType","options","result","toDriver","sql","match","pt","mp"],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/consistent-type-definitions */\n// Inspired by @link https://github.com/drizzle-team/drizzle-orm/discussions/123#discussioncomment-6075834\nimport { sql } from \"drizzle-orm\";\nimport { customType } from \"drizzle-orm/pg-core\";\nimport type * as GeoJSON from \"~/geojsonTypes\";\n\nimport wkx from \"wkx\";\n\nexport type BaseGeometryType =\n  | \"Point\"\n  | \"MultiPoint\"\n  | \"LineString\"\n  | \"MultiLineString\"\n  | \"Polygon\"\n  | \"MultiPolygon\"\n  | \"GeometryCollection\";\n\nexport type GeometryType = BaseGeometryType | `${BaseGeometryType}Z`;\n\nexport type GeometryOptions =\n  | { type?: GeometryType; srid?: never; is3D?: boolean }\n  | { type: GeometryType; srid: number; is3D?: boolean };\n\nexport type GeometrySubtypeOptions = { srid?: number; is3D?: boolean };\n\nconst dataType = (options?: GeometryOptions) => {\n  let result = \"geometry\";\n  if (options?.type) {\n    result += `(${options.type}`;\n    if (options?.srid) {\n      result += `,${options.srid}`;\n    }\n\n    return `${result})`;\n  }\n  return `${result}(Geometry)`;\n};\n\nfunction toDriver(value: GeoJSON.Geometry) {\n  return sql`ST_GeomFromGeoJSON(${JSON.stringify(value)})`;\n}\n\n/** Internal function used for mapping Drizzle results\n * @internal\n */\nexport function fromDriver<T extends GeoJSON.Geometry>(value: string) {\n  const b = Buffer.from(value, \"hex\");\n  // Dependency on wkx can be removed once @link https://github.com/drizzle-team/drizzle-orm/pull/1423 is merged\n  return wkx.Geometry.parse(b).toGeoJSON({ shortCrs: true }) as T;\n}\n\n/** Internal function used for mapping Drizzle results\n *  @internal\n */\nexport function box2DfromDriver(value: string): GeoJSON.BBox {\n  const match = value.match(\n    /BOX\\((?<xmin>[0-9\\.]+),? ?(?<ymin>[0-9\\.]+),? ?(?<xmax>[0-9\\.]+),? ?(?<ymax>[0-9\\.]+)\\)/\n  );\n  if (!match?.groups) throw new Error(`Box2D parse error, value: ${value}`);\n  return [\n    Number.parseFloat(match.groups.xmin),\n    Number.parseFloat(match.groups.ymin),\n    Number.parseFloat(match.groups.xmax),\n    Number.parseFloat(match.groups.ymax),\n  ];\n}\n\n/** box2d is a spatial data type used to represent the two-dimensional bounding box enclosing a geometry or collection of geometries.\n *\n * The representation contains the values xmin, ymin, xmax, ymax. These are the minimum and maximum values of the X and Y extents.\n * @example `POINT (1 2)`\n *\n * @link https://postgis.net/docs/box2d_type.html\n */\nexport const box2D = customType<{\n  data: GeoJSON.Box2D;\n  driverData: string;\n}>({\n  dataType: () => \"box2d\",\n  toDriver: (b: GeoJSON.Box2D) => `BOX(${b[0]} ${b[1]}, ${b[2]} ${b[3]})`,\n  fromDriver: box2DfromDriver,\n});\n\n/** Geometry is a fundamental PostGIS spatial data type used to represent a feature in planar (Euclidean) coordinate systems.\n *\n * Geometry is an abstract type. Geometry values belong to one of its concrete subtypes which represent various kinds and dimensions of geometric shapes.\n * These include the atomic types Point, LineString, and Polygon,\n * and the collection types MultiPoint, MultiLineString, MultiPolygon and GeometryCollection.\n *\n * @link https://postgis.net/docs/geometry.html\n * @link https://postgis.net/docs/using_postgis_dbmanagement.html#OGC_Geometry\n */\nexport const geometry = customType<{\n  data: GeoJSON.Geometry;\n  config: GeometryOptions;\n  driverData: string;\n}>({\n  dataType,\n  toDriver: (pt: GeoJSON.Geometry) => toDriver(pt),\n  fromDriver: (value) => fromDriver<GeoJSON.Geometry>(value),\n});\n\n/** A Point is a 0-dimensional geometry that represents a single location in coordinate space.\n *\n * @example `POINT (1 2)`\n *\n * @link https://postgis.net/docs/using_postgis_dbmanagement.html#Point\n */\nexport const point = customType<{\n  data: GeoJSON.Point;\n  config: GeometrySubtypeOptions;\n  driverData: string;\n}>({\n  dataType: (options) =>\n    dataType({ type: `Point${options?.is3D ? \"Z\" : \"\"}`, ...options }),\n  toDriver: (pt: GeoJSON.Point) => toDriver(pt),\n  fromDriver: (value) => fromDriver<GeoJSON.Point>(value),\n});\n\n/** A MultiPoint is a collection of Points.\n *\n * @example `MULTIPOINT ( (0 0), (1 2) )`\n *\n * @link https://postgis.net/docs/using_postgis_dbmanagement.html#MultiPoint\n */\nexport const multiPoint = customType<{\n  data: GeoJSON.MultiPoint;\n  config: GeometrySubtypeOptions;\n  driverData: string;\n}>({\n  dataType: (options) =>\n    dataType({ type: `MultiPoint${options?.is3D ? \"Z\" : \"\"}`, ...options }),\n  toDriver: (pt: GeoJSON.MultiPoint) => toDriver(pt),\n  fromDriver: (value) => fromDriver<GeoJSON.MultiPoint>(value),\n});\n\n/** A LineString is a 1-dimensional line formed by a contiguous sequence of line segments.\n *\n * Each line segment is defined by two points, with the end point of one segment forming the start point of the next segment.\n * An OGC-valid LineString has either zero or two or more points, but PostGIS also allows single-point LineStrings.\n * LineStrings may cross themselves (self-intersect). A LineString is closed if the start and end points are the same.\n * A LineString is simple if it does not self-intersect.\n *\n * @example `LINESTRING (1 2, 3 4, 5 6)`\n *\n * @link https://postgis.net/docs/using_postgis_dbmanagement.html#LineString\n */\nexport const lineString = customType<{\n  data: GeoJSON.LineString;\n  config: GeometrySubtypeOptions;\n  driverData: string;\n}>({\n  dataType: (options) =>\n    dataType({ type: `LineString${options?.is3D ? \"Z\" : \"\"}`, ...options }),\n  toDriver: (pt: GeoJSON.LineString) => toDriver(pt),\n  fromDriver: (value) => fromDriver<GeoJSON.LineString>(value),\n});\n\n/** A MultiLineString is a collection of LineStrings.\n *\n * A MultiLineString is closed if each of its elements is closed.\n *\n * @example `MULTILINESTRING ( (0 0,1 1,1 2), (2 3,3 2,5 4) )`\n *\n * @link https://postgis.net/docs/using_postgis_dbmanagement.html#MultiLineString\n */\nexport const multiLineString = customType<{\n  data: GeoJSON.MultiLineString;\n  config: GeometrySubtypeOptions;\n  driverData: string;\n}>({\n  dataType: (options) =>\n    dataType({\n      type: `MultiLineString${options?.is3D ? \"Z\" : \"\"}`,\n      ...options,\n    }),\n  toDriver: (pt: GeoJSON.MultiLineString) => toDriver(pt),\n  fromDriver: (value) => fromDriver<GeoJSON.MultiLineString>(value),\n});\n\n/** A Polygon is a 2-dimensional planar region, delimited by an exterior boundary (the shell) and zero or more interior boundaries (holes).\n *\n * Each boundary is a LinearRing. A LinearRing is a LineString which is both closed and simple.\n * The first and last points must be equal, and the line must not self-intersect.\n *\n * @example `POLYGON ((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0))`\n *\n * @link https://postgis.net/docs/using_postgis_dbmanagement.html#Polygon\n */\nexport const polygon = customType<{\n  data: GeoJSON.Polygon;\n  config: GeometrySubtypeOptions;\n  driverData: string;\n}>({\n  dataType: (options) =>\n    dataType({ type: `Polygon${options?.is3D ? \"Z\" : \"\"}`, ...options }),\n  toDriver: (mp: GeoJSON.Polygon) => toDriver(mp),\n  fromDriver: (value) => fromDriver<GeoJSON.Polygon>(value),\n});\n\n/**\n * A MultiPolygon is a collection of non-overlapping, non-adjacent Polygons.\n *\n * Polygons in the collection may touch only at a finite number of points.\n *\n * @example `MULTIPOLYGON (((1 5, 5 5, 5 1, 1 1, 1 5)), ((6 5, 9 1, 6 1, 6 5)))`\n *\n * @link https://postgis.net/docs/using_postgis_dbmanagement.html#MultiPolygon\n */\nexport const multiPolygon = customType<{\n  data: GeoJSON.MultiPolygon;\n  config: GeometrySubtypeOptions;\n  driverData: string;\n}>({\n  dataType: (options) =>\n    dataType({ type: `MultiPolygon${options?.is3D ? \"Z\" : \"\"}`, ...options }),\n  toDriver: (mp: GeoJSON.MultiPolygon) => toDriver(mp),\n  fromDriver: (value) => fromDriver<GeoJSON.MultiPolygon>(value),\n});\n\n/** A GeometryCollection is a heterogeneous (mixed) collection of geometries.\n *\n * @example `GEOMETRYCOLLECTION ( POINT(2 3), LINESTRING(2 3, 3 4))`\n *\n * @link https://postgis.net/docs/using_postgis_dbmanagement.html#GeometryCollection\n */\nexport const geometryCollection = customType<{\n  data: GeoJSON.GeometryCollection;\n  config: Omit<GeometrySubtypeOptions, \"dimensions\">;\n  driverData: string;\n}>({\n  dataType: (options) =>\n    dataType({\n      type: \"GeometryCollection\",\n      ...options,\n    }),\n  toDriver: (mp: GeoJSON.GeometryCollection) => toDriver(mp),\n  fromDriver: (value) => fromDriver<GeoJSON.GeometryCollection>(value),\n});\n","import type { AnyColumn } from './column.ts';\nimport { Column } from './column.ts';\nimport { is } from './entity.ts';\nimport type { Logger } from './logger.ts';\nimport type { SelectedFieldsOrdered } from './operations.ts';\nimport type { TableLike } from './query-builders/select.types.ts';\nimport { Param, SQL, View } from './sql/sql.ts';\nimport type { DriverValueDecoder } from './sql/sql.ts';\nimport { Subquery } from './subquery.ts';\nimport { getTableName, Table } from './table.ts';\nimport { ViewBaseConfig } from './view-common.ts';\n\n/** @internal */\nexport function mapResultRow<TResult>(\n\tcolumns: SelectedFieldsOrdered<AnyColumn>,\n\trow: unknown[],\n\tjoinsNotNullableMap: Record<string, boolean> | undefined,\n): TResult {\n\t// Key -> nested object key, value -> table name if all fields in the nested object are from the same table, false otherwise\n\tconst nullifyMap: Record<string, string | false> = {};\n\n\tconst result = columns.reduce<Record<string, any>>(\n\t\t(result, { path, field }, columnIndex) => {\n\t\t\tlet decoder: DriverValueDecoder<unknown, unknown>;\n\t\t\tif (is(field, Column)) {\n\t\t\t\tdecoder = field;\n\t\t\t} else if (is(field, SQL)) {\n\t\t\t\tdecoder = field.decoder;\n\t\t\t} else {\n\t\t\t\tdecoder = field.sql.decoder;\n\t\t\t}\n\t\t\tlet node = result;\n\t\t\tfor (const [pathChunkIndex, pathChunk] of path.entries()) {\n\t\t\t\tif (pathChunkIndex < path.length - 1) {\n\t\t\t\t\tif (!(pathChunk in node)) {\n\t\t\t\t\t\tnode[pathChunk] = {};\n\t\t\t\t\t}\n\t\t\t\t\tnode = node[pathChunk];\n\t\t\t\t} else {\n\t\t\t\t\tconst rawValue = row[columnIndex]!;\n\t\t\t\t\tconst value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);\n\n\t\t\t\t\tif (joinsNotNullableMap && is(field, Column) && path.length === 2) {\n\t\t\t\t\t\tconst objectName = path[0]!;\n\t\t\t\t\t\tif (!(objectName in nullifyMap)) {\n\t\t\t\t\t\t\tnullifyMap[objectName] = value === null ? getTableName(field.table) : false;\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\ttypeof nullifyMap[objectName] === 'string' && nullifyMap[objectName] !== getTableName(field.table)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tnullifyMap[objectName] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\t{},\n\t);\n\n\t// Nullify all nested objects from nullifyMap that are nullable\n\tif (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {\n\t\tfor (const [objectName, tableName] of Object.entries(nullifyMap)) {\n\t\t\tif (typeof tableName === 'string' && !joinsNotNullableMap[tableName]) {\n\t\t\t\tresult[objectName] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result as TResult;\n}\n\n/** @internal */\nexport function orderSelectedFields<TColumn extends AnyColumn>(\n\tfields: Record<string, unknown>,\n\tpathPrefix?: string[],\n): SelectedFieldsOrdered<TColumn> {\n\treturn Object.entries(fields).reduce<SelectedFieldsOrdered<AnyColumn>>((result, [name, field]) => {\n\t\tif (typeof name !== 'string') {\n\t\t\treturn result;\n\t\t}\n\n\t\tconst newPath = pathPrefix ? [...pathPrefix, name] : [name];\n\t\tif (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {\n\t\t\tresult.push({ path: newPath, field });\n\t\t} else if (is(field, Table)) {\n\t\t\tresult.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));\n\t\t} else {\n\t\t\tresult.push(...orderSelectedFields(field as Record<string, unknown>, newPath));\n\t\t}\n\t\treturn result;\n\t}, []) as SelectedFieldsOrdered<TColumn>;\n}\n\nexport function haveSameKeys(left: Record<string, unknown>, right: Record<string, unknown>) {\n\tconst leftKeys = Object.keys(left);\n\tconst rightKeys = Object.keys(right);\n\n\tif (leftKeys.length !== rightKeys.length) {\n\t\treturn false;\n\t}\n\n\tfor (const [index, key] of leftKeys.entries()) {\n\t\tif (key !== rightKeys[index]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/** @internal */\nexport function mapUpdateSet(table: Table, values: Record<string, unknown>): UpdateSet {\n\tconst entries: [string, UpdateSet[string]][] = Object.entries(values)\n\t\t.filter(([, value]) => value !== undefined)\n\t\t.map(([key, value]) => {\n\t\t\t// eslint-disable-next-line unicorn/prefer-ternary\n\t\t\tif (is(value, SQL) || is(value, Column)) {\n\t\t\t\treturn [key, value];\n\t\t\t} else {\n\t\t\t\treturn [key, new Param(value, table[Table.Symbol.Columns][key])];\n\t\t\t}\n\t\t});\n\n\tif (entries.length === 0) {\n\t\tthrow new Error('No values to set');\n\t}\n\n\treturn Object.fromEntries(entries);\n}\n\nexport type UpdateSet = Record<string, SQL | Param | AnyColumn | null | undefined>;\n\nexport type OneOrMany<T> = T | T[];\n\nexport type Update<T, TUpdate> =\n\t& {\n\t\t[K in Exclude<keyof T, keyof TUpdate>]: T[K];\n\t}\n\t& TUpdate;\n\nexport type Simplify<T> =\n\t& {\n\t\t// @ts-ignore - \"Type parameter 'K' has a circular constraint\", not sure why\n\t\t[K in keyof T]: T[K];\n\t}\n\t& {};\n\nexport type SimplifyMappedType<T> = [T] extends [unknown] ? T : never;\n\nexport type ShallowRecord<K extends keyof any, T> = SimplifyMappedType<{ [P in K]: T }>;\n\nexport type Assume<T, U> = T extends U ? T : U;\n\nexport type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends (<T>() => T extends Y ? 1 : 2) ? true : false;\n\nexport interface DrizzleTypeError<T extends string> {\n\t$drizzleTypeError: T;\n}\n\nexport type ValueOrArray<T> = T | T[];\n\n/** @internal */\nexport function applyMixins(baseClass: any, extendedClasses: any[]) {\n\tfor (const extendedClass of extendedClasses) {\n\t\tfor (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {\n\t\t\tif (name === 'constructor') continue;\n\n\t\t\tObject.defineProperty(\n\t\t\t\tbaseClass.prototype,\n\t\t\t\tname,\n\t\t\t\tObject.getOwnPropertyDescriptor(extendedClass.prototype, name) || Object.create(null),\n\t\t\t);\n\t\t}\n\t}\n}\n\nexport type Or<T1, T2> = T1 extends true ? true : T2 extends true ? true : false;\n\nexport type IfThenElse<If, Then, Else> = If extends true ? Then : Else;\n\nexport type PromiseOf<T> = T extends Promise<infer U> ? U : T;\n\nexport type Writable<T> = {\n\t-readonly [P in keyof T]: T[P];\n};\n\nexport function getTableColumns<T extends Table>(table: T): T['_']['columns'] {\n\treturn table[Table.Symbol.Columns];\n}\n\nexport function getViewSelectedFields<T extends View>(view: T): T['_']['selectedFields'] {\n\treturn view[ViewBaseConfig].selectedFields;\n}\n\n/** @internal */\nexport function getTableLikeName(table: TableLike): string | undefined {\n\treturn is(table, Subquery)\n\t\t? table._.alias\n\t\t: is(table, View)\n\t\t? table[ViewBaseConfig].name\n\t\t: is(table, SQL)\n\t\t? undefined\n\t\t: table[Table.Symbol.IsAlias]\n\t\t? table[Table.Symbol.Name]\n\t\t: table[Table.Symbol.BaseName];\n}\n\nexport type ColumnsWithTable<\n\tTTableName extends string,\n\tTForeignTableName extends string,\n\tTColumns extends AnyColumn<{ tableName: TTableName }>[],\n> = { [Key in keyof TColumns]: AnyColumn<{ tableName: TForeignTableName }> };\n\nexport type Casing = 'snake_case' | 'camelCase';\n\nexport interface DrizzleConfig<TSchema extends Record<string, unknown> = Record<string, never>> {\n\tlogger?: boolean | Logger;\n\tschema?: TSchema;\n\tcasing?: Casing;\n}\nexport type ValidateShape<T, ValidShape, TResult = T> = T extends ValidShape\n\t? Exclude<keyof T, keyof ValidShape> extends never ? TResult\n\t: DrizzleTypeError<\n\t\t`Invalid key(s): ${Exclude<(keyof T) & (string | number | bigint | boolean | null | undefined), keyof ValidShape>}`\n\t>\n\t: never;\n\nexport type KnownKeysOnly<T, U> = {\n\t[K in keyof T]: K extends keyof U ? T[K] : never;\n};\n\nexport type IsAny<T> = 0 extends (1 & T) ? true : false;\n\n/** @internal */\nexport function getColumnNameAndConfig<\n\tTConfig extends Record<string, any> | undefined,\n>(a: string | TConfig | undefined, b: TConfig | undefined) {\n\treturn {\n\t\tname: typeof a === 'string' && a.length > 0 ? a : '' as string,\n\t\tconfig: typeof a === 'object' ? a : b as TConfig,\n\t};\n}\n\nexport type IfNotImported<T, Y, N> = unknown extends T ? Y : N;\n\nexport type ImportTypeError<TPackageName extends string> =\n\t`Please install \\`${TPackageName}\\` to allow Drizzle ORM to connect to the database`;\n\nexport type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Keys extends any\n\t? Required<Pick<T, Keys>> & Partial<Omit<T, Keys>>\n\t: never;\n\ntype ExpectedConfigShape = {\n\tlogger?: boolean | {\n\t\tlogQuery(query: string, params: unknown[]): void;\n\t};\n\tschema?: Record<string, never>;\n\tcasing?: 'snake_case' | 'camelCase';\n};\n\n// If this errors, you must update config shape checker function with new config specs\nconst _: DrizzleConfig = {} as ExpectedConfigShape;\nconst __: ExpectedConfigShape = {} as DrizzleConfig;\n\nexport function isConfig(data: any): boolean {\n\tif (typeof data !== 'object' || data === null) return false;\n\n\tif (data.constructor.name !== 'Object') return false;\n\n\tif ('logger' in data) {\n\t\tconst type = typeof data['logger'];\n\t\tif (\n\t\t\ttype !== 'boolean' && (type !== 'object' || typeof data['logger']['logQuery'] !== 'function')\n\t\t\t&& type !== 'undefined'\n\t\t) return false;\n\n\t\treturn true;\n\t}\n\n\tif ('schema' in data) {\n\t\tconst type = typeof data['logger'];\n\t\tif (type !== 'object' && type !== 'undefined') return false;\n\n\t\treturn true;\n\t}\n\n\tif ('casing' in data) {\n\t\tconst type = typeof data['logger'];\n\t\tif (type !== 'string' && type !== 'undefined') return false;\n\n\t\treturn true;\n\t}\n\n\tif ('mode' in data) {\n\t\tif (data['mode'] !== 'default' || data['mode'] !== 'planetscale' || data['mode'] !== undefined) return false;\n\n\t\treturn true;\n\t}\n\n\tif ('connection' in data) {\n\t\tconst type = typeof data['connection'];\n\t\tif (type !== 'string' && type !== 'object' && type !== 'undefined') return false;\n\n\t\treturn true;\n\t}\n\n\tif ('client' in data) {\n\t\tconst type = typeof data['client'];\n\t\tif (type !== 'object' && type !== 'function' && type !== 'undefined') return false;\n\n\t\treturn true;\n\t}\n\n\tif (Object.keys(data).length === 0) return true;\n\n\treturn false;\n}\n\nexport type NeonAuthToken = string | (() => string | Promise<string>);\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport type { SQL } from '~/sql/sql.ts';\nimport { type Equal, getColumnNameAndConfig } from '~/utils.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type ConvertCustomConfig<TName extends string, T extends Partial<CustomTypeValues>> =\n\t& {\n\t\tname: TName;\n\t\tdataType: 'custom';\n\t\tcolumnType: 'PgCustomColumn';\n\t\tdata: T['data'];\n\t\tdriverParam: T['driverData'];\n\t\tenumValues: undefined;\n\t}\n\t& (T['notNull'] extends true ? { notNull: true } : {})\n\t& (T['default'] extends true ? { hasDefault: true } : {});\n\nexport interface PgCustomColumnInnerConfig {\n\tcustomTypeValues: CustomTypeValues;\n}\n\nexport class PgCustomColumnBuilder<T extends ColumnBuilderBaseConfig<'custom', 'PgCustomColumn'>>\n\textends PgColumnBuilder<\n\t\tT,\n\t\t{\n\t\t\tfieldConfig: CustomTypeValues['config'];\n\t\t\tcustomTypeParams: CustomTypeParams<any>;\n\t\t},\n\t\t{\n\t\t\tpgColumnBuilderBrand: 'PgCustomColumnBuilderBrand';\n\t\t}\n\t>\n{\n\tstatic override readonly [entityKind]: string = 'PgCustomColumnBuilder';\n\n\tconstructor(\n\t\tname: T['name'],\n\t\tfieldConfig: CustomTypeValues['config'],\n\t\tcustomTypeParams: CustomTypeParams<any>,\n\t) {\n\t\tsuper(name, 'custom', 'PgCustomColumn');\n\t\tthis.config.fieldConfig = fieldConfig;\n\t\tthis.config.customTypeParams = customTypeParams;\n\t}\n\n\t/** @internal */\n\tbuild<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgCustomColumn<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgCustomColumn<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgCustomColumn<T extends ColumnBaseConfig<'custom', 'PgCustomColumn'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgCustomColumn';\n\n\tprivate sqlName: string;\n\tprivate mapTo?: (value: T['data']) => T['driverParam'];\n\tprivate mapFrom?: (value: T['driverParam']) => T['data'];\n\n\tconstructor(\n\t\ttable: AnyPgTable<{ name: T['tableName'] }>,\n\t\tconfig: PgCustomColumnBuilder<T>['config'],\n\t) {\n\t\tsuper(table, config);\n\t\tthis.sqlName = config.customTypeParams.dataType(config.fieldConfig);\n\t\tthis.mapTo = config.customTypeParams.toDriver;\n\t\tthis.mapFrom = config.customTypeParams.fromDriver;\n\t}\n\n\tgetSQLType(): string {\n\t\treturn this.sqlName;\n\t}\n\n\toverride mapFromDriverValue(value: T['driverParam']): T['data'] {\n\t\treturn typeof this.mapFrom === 'function' ? this.mapFrom(value) : value as T['data'];\n\t}\n\n\toverride mapToDriverValue(value: T['data']): T['driverParam'] {\n\t\treturn typeof this.mapTo === 'function' ? this.mapTo(value) : value as T['data'];\n\t}\n}\n\nexport type CustomTypeValues = {\n\t/**\n\t * Required type for custom column, that will infer proper type model\n\t *\n\t * Examples:\n\t *\n\t * If you want your column to be `string` type after selecting/or on inserting - use `data: string`. Like `text`, `varchar`\n\t *\n\t * If you want your column to be `number` type after selecting/or on inserting - use `data: number`. Like `integer`\n\t */\n\tdata: unknown;\n\n\t/**\n\t * Type helper, that represents what type database driver is accepting for specific database data type\n\t */\n\tdriverData?: unknown;\n\n\t/**\n\t * What config type should be used for {@link CustomTypeParams} `dataType` generation\n\t */\n\tconfig?: Record<string, any>;\n\n\t/**\n\t * Whether the config argument should be required or not\n\t * @default false\n\t */\n\tconfigRequired?: boolean;\n\n\t/**\n\t * If your custom data type should be notNull by default you can use `notNull: true`\n\t *\n\t * @example\n\t * const customSerial = customType<{ data: number, notNull: true, default: true }>({\n\t * \t  dataType() {\n\t * \t    return 'serial';\n\t *    },\n\t * });\n\t */\n\tnotNull?: boolean;\n\n\t/**\n\t * If your custom data type has default you can use `default: true`\n\t *\n\t * @example\n\t * const customSerial = customType<{ data: number, notNull: true, default: true }>({\n\t * \t  dataType() {\n\t * \t    return 'serial';\n\t *    },\n\t * });\n\t */\n\tdefault?: boolean;\n};\n\nexport interface CustomTypeParams<T extends CustomTypeValues> {\n\t/**\n\t * Database data type string representation, that is used for migrations\n\t * @example\n\t * ```\n\t * `jsonb`, `text`\n\t * ```\n\t *\n\t * If database data type needs additional params you can use them from `config` param\n\t * @example\n\t * ```\n\t * `varchar(256)`, `numeric(2,3)`\n\t * ```\n\t *\n\t * To make `config` be of specific type please use config generic in {@link CustomTypeValues}\n\t *\n\t * @example\n\t * Usage example\n\t * ```\n\t *   dataType() {\n\t *     return 'boolean';\n\t *   },\n\t * ```\n\t * Or\n\t * ```\n\t *   dataType(config) {\n\t * \t   return typeof config.length !== 'undefined' ? `varchar(${config.length})` : `varchar`;\n\t * \t }\n\t * ```\n\t */\n\tdataType: (config: T['config'] | (Equal<T['configRequired'], true> extends true ? never : undefined)) => string;\n\n\t/**\n\t * Optional mapping function, between user input and driver\n\t * @example\n\t * For example, when using jsonb we need to map JS/TS object to string before writing to database\n\t * ```\n\t * toDriver(value: TData): string {\n\t * \t return JSON.stringify(value);\n\t * }\n\t * ```\n\t */\n\ttoDriver?: (value: T['data']) => T['driverData'] | SQL;\n\n\t/**\n\t * Optional mapping function, that is responsible for data mapping from database to JS/TS code\n\t * @example\n\t * For example, when using timestamp we need to map string Date representation to JS Date\n\t * ```\n\t * fromDriver(value: string): Date {\n\t * \treturn new Date(value);\n\t * },\n\t * ```\n\t */\n\tfromDriver?: (value: T['driverData']) => T['data'];\n}\n\n/**\n * Custom pg database data type generator\n */\nexport function customType<T extends CustomTypeValues = CustomTypeValues>(\n\tcustomTypeParams: CustomTypeParams<T>,\n): Equal<T['configRequired'], true> extends true ? {\n\t\t<TConfig extends Record<string, any> & T['config']>(\n\t\t\tfieldConfig: TConfig,\n\t\t): PgCustomColumnBuilder<ConvertCustomConfig<'', T>>;\n\t\t<TName extends string>(\n\t\t\tdbName: TName,\n\t\t\tfieldConfig: T['config'],\n\t\t): PgCustomColumnBuilder<ConvertCustomConfig<TName, T>>;\n\t}\n\t: {\n\t\t(): PgCustomColumnBuilder<ConvertCustomConfig<'', T>>;\n\t\t<TConfig extends Record<string, any> & T['config']>(\n\t\t\tfieldConfig?: TConfig,\n\t\t): PgCustomColumnBuilder<ConvertCustomConfig<'', T>>;\n\t\t<TName extends string>(\n\t\t\tdbName: TName,\n\t\t\tfieldConfig?: T['config'],\n\t\t): PgCustomColumnBuilder<ConvertCustomConfig<TName, T>>;\n\t}\n{\n\treturn <TName extends string>(\n\t\ta?: TName | T['config'],\n\t\tb?: T['config'],\n\t): PgCustomColumnBuilder<ConvertCustomConfig<TName, T>> => {\n\t\tconst { name, config } = getColumnNameAndConfig<T['config']>(a, b);\n\t\treturn new PgCustomColumnBuilder(name as ConvertCustomConfig<TName, T>['name'], config, customTypeParams);\n\t};\n}\n"]}